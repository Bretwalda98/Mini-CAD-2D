<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Mini-CAD 2D — Compatibility Pro r5d (Blocks)</title>
<style>
  :root{
    --bg:#0b0e14; --panel:#121625; --ink:#e8ecf1; --muted:#9aa4b2; --accent:#4da3ff; --accent2:#47e5a1;
    --grid-minor:#2e344a; --grid-major:#4f5b88; --axis:#7aa2ff; --sel:#7aa2ff33; --hud:#0e1628cc; --hud-border:#2a3a70;
  }
  *{box-sizing:border-box}
  html,body{height:100%; margin:0; background:var(--bg); color:var(--ink); font-family:Arial,Helvetica,system-ui; overscroll-behavior:none}
  #app{display:grid; grid-template-columns:auto 1fr 320px; grid-template-rows:auto 1fr auto; grid-template-areas:
    "top top top"
    "left mid right"
    "bot bot bot"; height:100vh}
  header{grid-area:top; display:flex; align-items:center; gap:.5rem; padding:.5rem; background:var(--panel); border-bottom:1px solid #1e2335; flex-wrap:wrap}
  header .seg{display:inline-flex; gap:.4rem; flex-wrap:wrap; align-items:center}
  header button{background:#171c2b; color:var(--ink); border:1px solid #263050; padding:.45rem .7rem; border-radius:.4rem; cursor:pointer; font-size:.95rem}
  header button:hover{border-color:#2f3b68}
  header label{display:inline-flex; align-items:center; gap:.45rem; color:#c9d1e0; font-size:.9rem; margin:0 .25rem}
  #left{grid-area:left; position:relative; padding:.5rem}
  #toolbox{
    position:sticky; top:.5rem; display:flex; flex-direction:column; gap:.5rem;
    background:#11162aee; border:1px solid #2a3358; border-radius:.5rem; padding:.5rem;
  }
  #toolbox button{width:44px; height:44px; background:#161c32; color:#dfe7ff; border:1px solid #2c3861; border-radius:.4rem; cursor:pointer; font-size:.85rem}
  #toolbox button.active{outline:2px solid var(--accent)}
  #toolbox .row{display:flex; flex-wrap:wrap; gap:.35rem}
  #toolbox .group{display:flex; flex-direction:column; gap:.35rem}
  #toolbox .title{font-size:.75rem; color:#aab6d8; text-align:center}
  #mid{grid-area:mid; position:relative; min-height: 200px;}
  canvas{display:block; width:100%; height:100%; background:transparent; touch-action:none; cursor:none}
  #hud{
    position:absolute; pointer-events:none; display:none;
    background:var(--hud); color:#e4eeff; border:1px solid var(--hud-border); border-radius:.4rem; padding:.25rem .35rem; font:12px/1.2 monospace;
    min-width:120px; z-index:8;
  }
  #hud .row{display:flex; justify-content:space-between; gap:.4rem}
  #hud .key{color:#9ab3ff}
  #hud .active{outline:1px dashed #7db6ff; outline-offset:2px; border-radius:.2rem; padding:0 2px;}
  #right{grid-area:right; background:#0f1426; border-left:1px solid #1e2335; padding:.5rem; overflow:auto}
  #panel h3{margin:.6rem 0 .4rem; font-size:1rem; color:#cfe3ff}
  #panel .row{display:flex; align-items:center; justify-content:space-between; margin:.25rem 0; gap:.4rem}
  #panel input[type="color"]{width:36px; height:24px; border:1px solid #2a3358; background:#0b0e14}
  #panel select, #panel input[type="text"], #panel input[type="number"]{flex:1; background:#101425; color:#e6e6e6; border:1px solid #1e2436; border-radius:.25rem; padding:.25rem .35rem}
  #cmd{grid-area:bot; padding:.4rem .6rem; background:#0e1324; border-top:1px solid #1e2335; display:flex; gap:.5rem; align-items:center; color:#9aa4b2; font:14px/1.2 monospace; flex-wrap:wrap}
  #status{margin-left:auto; color:#9aa4b2; font:14px/1.2 monospace}
  #okpill{padding:.2rem .45rem; border:1px solid #2a375b; border-radius:.4rem; margin-left:.25rem}
  #err{position:absolute; left:8px; bottom:8px; background:#330d10; color:#ffd7d7; border:1px solid #5a1e1e; padding:.4rem .5rem; border-radius:.4rem; font:12px/1.2 monospace; display:none; max-width:90vw; white-space:pre-wrap; z-index:50}
  #fileInput{display:none}
  .pill{padding:.1rem .4rem; border:1px solid #2a3046; border-radius:.4rem; background:#12182a; color:#fff}
  .toggle{display:inline-flex; align-items:center; gap:.3rem; margin-right:.6rem}
  .hint{color:#94a3b8; font-size:12px; margin-top:.35rem}
  .small{font-size:.85rem; color:#9aa4b2}
  @media (max-width: 900px){
    #app{grid-template-columns: auto 1fr; grid-template-rows:auto 1fr auto auto; grid-template-areas:
      "top top"
      "left mid"
      "right right"
      "bot bot";}
  }
</style>
</head>
<body>
<div id="app">
  <header>
    <div class="seg">
      <button id="openBtn" title="Open JSON/DXF (Ctrl+O)">Open</button>
      <button id="saveBtn" title="Save JSON (Ctrl+S)">Save</button>
      <button id="saveDxfBtn" title="Save As DXF">DXF</button>
      <input type="file" id="fileInput" accept=".json,.dxf,.txt" />
      <span id="okpill">Loading…</span>
    </div>
    <div class="seg">
      <label class="toggle"><input type="checkbox" id="showGrid" checked />Grid</label>
      <label class="toggle"><input type="checkbox" id="snapGrid" checked />Snap Grid</label>
      <label class="toggle"><input type="checkbox" id="snapEnds" checked />Snap End</label>
      <label class="toggle"><input type="checkbox" id="snapMids" checked />Snap Mid</label>
      <label class="toggle"><input type="checkbox" id="snapInters" />Snap Int</label>
      <label class="toggle"><input type="checkbox" id="orthoLock" />Ortho (F8)</label>
      <label class="toggle">Grid <input id="gridStep" type="number" min="5" max="500" step="5" value="50" style="width:5.5rem" /></label>
      <label class="toggle"><input type="checkbox" id="bigCross" checked />ACAD Cursor</label>
      <label class="toggle">Pickbox <input id="pickSize" type="number" min="4" max="40" step="1" value="12" style="width:4.5rem" /></label>
      <button id="forceRedraw">Redraw</button>
      <button id="resetView">Reset View</button>
    </div>
  </header>

  <div id="left">
    <div id="toolbox">
      <div class="group">
        <div class="title">Draw</div>
        <div class="row">
          <button id="tb-select" class="active" title="Select (V)">Sel</button>
          <button id="tb-line" title="Line (L)">Line</button>
          <button id="tb-poly" title="Polyline (PL)">Pline</button>
          <button id="tb-rect" title="Rectangle (REC)">Rect</button>
          <button id="tb-circle" title="Circle (C)">Circ</button>
        </div>
      </div>
      <div class="group">
        <div class="title">Modify</div>
        <div class="row">
          <button id="tb-erase" title="Erase (E)">Erase</button>
        </div>
      </div>
      <div class="group">
        <div class="title">Blocks</div>
        <div class="row">
          <button id="tb-make-block" title="Make Block from Selection (B)">BMake</button>
          <button id="tb-insert-block" title="Insert Block (I)">BIns</button>
          <button id="tb-explode" title="Explode Block (X)">Explode</button>
        </div>
      </div>
      <div class="group">
        <div class="title">View</div>
        <div class="row">
          <button id="tb-pan" title="Pan (Middle/Right drag)">Pan</button>
          <button id="tb-zoom-win" title="Zoom Window (Z→W)">ZWin</button>
          <button id="tb-zoom-prev" title="Zoom Previous (Z→P)">ZPrev</button>
          <button id="tb-zoom-ext" title="Zoom Extents (Z→E)">ZExt</button>
        </div>
      </div>
    </div>
  </div>

  <div id="mid">
    <canvas id="c"></canvas>
    <div id="hud">
      <div class="row"><span class="key">Len</span><span id="hudLen" class="active">—</span></div>
      <div class="row"><span class="key">Ang</span><span id="hudAng">—</span></div>
      <div class="row small"><span>dx,dy</span><span id="hudDXDY">—</span></div>
      <div class="row small"><span>snap</span><span id="hudSnap">—</span></div>
    </div>
    <pre id="err"></pre>
  </div>

  <aside id="right">
    <div id="panel">
      <h3>Layers</h3>
      <div class="row">
        <label for="layerSelect">Current</label>
        <select id="layerSelect"></select>
      </div>
      <div class="row">
        <input id="newLayerName" type="text" placeholder="New layer name" />
        <input id="newLayerColor" type="color" value="#e0e6ff" />
      </div>
      <div class="row">
        <button id="addLayerBtn">Add</button>
        <button id="toggleLayerBtn">Hide/Show</button>
        <button id="delLayerBtn">Delete</button>
      </div>

      <h3>Blocks</h3>
      <div class="row">
        <label for="blockName">Name</label>
        <input id="blockName" type="text" placeholder="e.g., Door-900" />
      </div>
      <div class="row">
        <label for="blockList">Library</label>
        <select id="blockList"></select>
      </div>
      <div class="hint">Make block from selection; base point is last pick. Then insert by name.</div>

      <h3>Properties</h3>
      <div id="propContent">
        <div class="row"><span>Selection:</span> <span id="selInfo">0</span></div>
        <div class="row">
          <label for="propLayer">Layer</label>
          <select id="propLayer"></select>
        </div>
        <div class="row">
          <label for="propColor">Color</label>
          <input id="propColor" type="color" value="#e0e6ff" />
        </div>
        <div class="row">
          <button id="applyProps">Apply</button>
        </div>
      </div>

      <h3>Command Line</h3>
      <div class="row">
        <input id="cmdInput" type="text" placeholder="Type: LINE, PLINE, REC, C, E, Z, BMAKE, BINS, EXPLODE" />
      </div>
    </div>
  </aside>

  <div id="cmd">
    <div>Mode: <span id="modeLbl" class="pill">Select</span></div>
    <div id="status">Snap <span id="snapLbl">—</span> • Cursor <span id="cursorLbl">0,0</span> • Zoom <span id="zoomLbl">100%</span></div>
  </div>
</div>

<script>
(function(){
  var okPill = document.getElementById('okpill');
  var err = document.getElementById('err');
  function showErr(msg){ err.style.display='block'; err.textContent = String(msg); okPill.textContent='Error ✗'; okPill.style.background='#4a1212'; }
  window.addEventListener('error', function(e){ showErr((e.message||'error') + (e.filename? ("\\n"+e.filename+":"+e.lineno):'')); });

  try{
    var canvas = document.getElementById('c');
    var ctx = canvas.getContext('2d');
    if(!ctx){ throw new Error('2D canvas not available.'); }
    var dpr = Math.max(1, window.devicePixelRatio || 1);
    function hypot2(a,b){ return Math.sqrt(a*a+b*b); }

    var state = {
      scale: 1.0, ox: 0, oy: 0,
      mode: 'select',
      mouse: {x:0,y:0, wx:0, wy:0},
      grid: {step: 50},
      snaps: {grid:true, ends:true, mids:true, inters:false},
      ortho: false, showGrid: true,
      cursor: {big:true, pick:12},
      layers: [{name:'0', color:'#e0e6ff', visible:true}],
      currentLayer: '0',
      blocks: {},
      drawing: {entities: [], selection: {}},
      action: null,
      viewPrev: null,
      history: [], future: [],
      lastCmd: '',
      dyn: {active:false, field:'len', lenStr:'', angStr:'', lastBase:null},
      pickOverride:null
    };

    var hud = document.getElementById('hud');
    var hudLen = document.getElementById('hudLen');
    var hudAng = document.getElementById('hudAng');
    var hudDXDY = document.getElementById('hudDXDY');
    var hudSnap = document.getElementById('hudSnap');

    function setCanvasSize(){
      var rect = canvas.getBoundingClientRect();
      canvas.width = Math.max(100, Math.floor(rect.width * dpr));
      canvas.height = Math.max(100, Math.floor(rect.height * dpr));
      ctx.setTransform(dpr,0,0,dpr,0,0);
      if(state.ox===0 && state.oy===0){ state.ox=rect.width/2; state.oy=rect.height/2; state.scale=1.0; }
      draw();
    }
    function w2s(x,y){ return {x:x*state.scale+state.ox, y:-y*state.scale+state.oy}; }
    function s2w(sx,sy){ return {x:(sx-state.ox)/state.scale, y:-(sy-state.oy)/state.scale}; }
    function fmt(v){ return (Math.round(v*100)/100).toFixed(2); }
    function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
    function getCSS(name){ var cs=getComputedStyle(document.documentElement).getPropertyValue(name); return cs ? cs.trim() : '#888'; }
    function currentLayerObj(){ for(var i=0;i<state.layers.length;i++){ if(state.layers[i].name===state.currentLayer) return state.layers[i]; } return state.layers[0]; }
    function currentLayerColor(name){ for(var i=0;i<state.layers.length;i++){ if(state.layers[i].name===name) return state.layers[i].color; } return '#e0e6ff'; }

    function snapshot(){
      state.history.push(JSON.stringify({entities:state.drawing.entities, layers:state.layers, currentLayer:state.currentLayer, blocks:state.blocks}));
      if(state.history.length>200) state.history.shift();
      state.future.length=0;
    }
    function undo(){ if(!state.history.length) return; state.future.push(JSON.stringify({entities:state.drawing.entities, layers:state.layers, currentLayer:state.currentLayer, blocks:state.blocks})); var d=JSON.parse(state.history.pop()); state.drawing.entities=d.entities||[]; state.layers=d.layers||state.layers; state.currentLayer=d.currentLayer||'0'; state.blocks=d.blocks||{}; rebuildLayerUI(); rebuildBlockUI(); clearSelection(); draw(); }
    function redo(){ if(!state.future.length) return; state.history.push(JSON.stringify({entities:state.drawing.entities, layers:state.layers, currentLayer:state.currentLayer, blocks:state.blocks})); var d=JSON.parse(state.future.pop()); state.drawing.entities=d.entities||[]; state.layers=d.layers||state.layers; state.currentLayer=d.currentLayer||'0'; state.blocks=d.blocks||{}; rebuildLayerUI(); rebuildBlockUI(); clearSelection(); draw(); }

    function draw(){
      ctx.setTransform(1,0,0,1,0,0);
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.setTransform(dpr,0,0,dpr,0,0);
      drawGrid(); drawEntities(); drawOverlays(); drawCrosshair();
      var snap=getSnap(state.mouse.wx,state.mouse.wy, state.mouse.x, state.mouse.y, state.pickOverride);
      document.getElementById('cursorLbl').textContent = fmt(state.mouse.wx)+','+fmt(state.mouse.wy);
      document.getElementById('zoomLbl').textContent = Math.round(state.scale*100)+'%';
      document.getElementById('snapLbl').textContent = snap? (state.pickOverride? (state.pickOverride+'*'):snap.kind) : '—';
      updateHUD(snap);
    }
    function drawGrid(){
      if(!state.showGrid) return;
      var rect = canvas.getBoundingClientRect();
      var stepW = state.grid.step;
      var stepS = stepW * state.scale;
      var majorEvery = 5;
      var majorStepS = stepS * majorEvery;
      var left=-state.ox, right=rect.width-state.ox, top=-state.oy, bottom=rect.height-state.oy;
      var startXMinor=Math.floor(left/stepS)*stepS, startYMinor=Math.floor(top/stepS)*stepS;
      var startXMajor=Math.floor(left/majorStepS)*majorStepS, startYMajor=Math.floor(top/majorStepS)*majorStepS;

      ctx.save(); ctx.translate(state.ox,state.oy);
      if(stepS < 8){
        var dotGap = Math.max(majorStepS, 24);
        var sx = Math.floor(left/dotGap)*dotGap;
        var sy = Math.floor(top/dotGap)*dotGap;
        ctx.fillStyle = getCSS('--grid-major');
        for(var x=sx;x<=right;x+=dotGap){
          for(var y=sy;y<=bottom;y+=dotGap){
            ctx.fillRect(x-0.5,y-0.5,1.5,1.5);
          }
        }
      } else {
        ctx.beginPath();
        for(var x2=startXMinor;x2<=right;x2+=stepS){ ctx.moveTo(x2,top); ctx.lineTo(x2,bottom); }
        for(var y2=startYMinor;y2<=bottom;y2+=stepS){ ctx.moveTo(left,y2); ctx.lineTo(right,y2); }
        ctx.lineWidth = 1; ctx.strokeStyle = getCSS('--grid-minor'); ctx.stroke();

        ctx.beginPath();
        for(var x3=startXMajor;x3<=right;x3+=majorStepS){ ctx.moveTo(x3,top); ctx.lineTo(x3,bottom); }
        for(var y3=startYMajor;y3<=bottom;y3+=majorStepS){ ctx.moveTo(left,y3); ctx.lineTo(right,y3); }
        ctx.lineWidth = 1.5; ctx.strokeStyle = getCSS('--grid-major'); ctx.stroke();
      }
      ctx.beginPath(); ctx.moveTo(-state.ox,0); ctx.lineTo(rect.width-state.ox,0); ctx.moveTo(0,-state.oy); ctx.lineTo(0,rect.height-state.oy);
      ctx.lineWidth=1.2; ctx.strokeStyle=getCSS('--axis'); ctx.stroke();
      ctx.restore();
    }
    function entVisible(e){
      for(var i=0;i<state.layers.length;i++){ var L=state.layers[i]; if(L.name===e.layer){ return L.visible!==false; } }
      return true;
    }
    function drawEntities(){
      ctx.lineCap='round'; ctx.lineJoin='round'; ctx.lineWidth=1.6;
      for(var i=0;i<state.drawing.entities.length;i++){
        var e = state.drawing.entities[i];
        if(!entVisible(e)) continue;
        if(e.type==='blockref'){ drawBlockRef(e); continue; }
        var col = e.color || currentLayerColor(e.layer) || '#e0e6ff';
        ctx.strokeStyle = col;
        ctx.beginPath();
        for(var j=0;j<e.pts.length;j++){
          var p = w2s(e.pts[j].x, e.pts[j].y);
          if(j===0) ctx.moveTo(p.x, p.y); else ctx.lineTo(p.x, p.y);
        }
        if(e.closed && e.pts.length>1){ var p0=w2s(e.pts[0].x,e.pts[0].y); ctx.lineTo(p0.x,p0.y); }
        ctx.stroke();
      }
      // selection grips for polys and block base
      for(var i2=0;i2<state.drawing.entities.length;i2++){
        if(!state.drawing.selection[i2]) continue;
        var ee=state.drawing.entities[i2];
        if(ee.type==='poly'){
          for(var k=0;k<ee.pts.length;k++){ var s=w2s(ee.pts[k].x,ee.pts[k].y); ctx.fillStyle=getCSS('--accent'); ctx.fillRect(s.x-3.5,s.y-3.5,7,7); }
        } else if(ee.type==='blockref'){
          var sb=w2s(ee.pos.x,ee.pos.y); ctx.fillStyle='#9de6ff'; ctx.fillRect(sb.x-3.5,sb.y-3.5,7,7);
        }
      }
    }
    function drawBlockRef(br){
      var blk=state.blocks[br.ref]; if(!blk) return;
      var col = br.color || currentLayerColor(br.layer) || '#e0e6ff';
      var ang= (br.rot||0)*Math.PI/180, sc=br.scale||1, cos=Math.cos(ang), sin=Math.sin(ang);
      function T(pt){
        var x=(pt.x - blk.base.x)*sc, y=(pt.y - blk.base.y)*sc;
        return {x: br.pos.x + x*cos - y*sin, y: br.pos.y + x*sin + y*cos};
      }
      ctx.strokeStyle = col; ctx.lineWidth=1.6;
      for(var i=0;i<blk.entities.length;i++){
        var e=blk.entities[i];
        if(e.type!=='poly') continue;
        ctx.beginPath();
        for(var j=0;j<e.pts.length;j++){
          var p = w2s(T(e.pts[j]).x, T(e.pts[j]).y);
          if(j===0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y);
        }
        if(e.closed && e.pts.length>1){ var p0=T(e.pts[0]); var s0=w2s(p0.x,p0.y); ctx.lineTo(s0.x,s0.y); }
        ctx.stroke();
      }
    }
    function drawOverlays(){
      if(state.action && state.action.type==='box'){
        var x = Math.min(state.action.x0,state.action.x1);
        var y = Math.min(state.action.y0,state.action.y1);
        var w = Math.abs(state.action.x1-state.action.x0);
        var h = Math.abs(state.action.y1-state.action.y0);
        ctx.fillStyle=getCSS('--sel'); ctx.strokeStyle='#7aa2ffaa'; ctx.lineWidth=1; ctx.fillRect(x,y,w,h); ctx.strokeRect(x,y,w,h);
      }
      if(state.action && state.action.type && state.action.pts && state.action.pts.length){
        var A=state.action, pts=A.pts;
        ctx.strokeStyle=getCSS('--accent2'); ctx.setLineDash([6,4]); ctx.beginPath();
        if(A.type==='drawRect' && pts.length>=1){
          var a=pts[0]; var b=A.preview||a;
          var r=[{x:a.x,y:a.y},{x:b.x,y:a.y},{x:b.x,y:b.y},{x:a.x,y:b.y},{x:a.x,y:a.y}];
          for(var i=0;i<r.length;i++){ var s=w2s(r[i].x,r[i].y); if(i===0) ctx.moveTo(s.x,s.y); else ctx.lineTo(s.x,s.y); }
        } else if(A.type==='drawCircle' && pts.length>=1){
          var c=pts[0]; var b2=A.preview||c; var rad=hypot2(b2.x-c.x, b2.y-c.y); var N=64;
          for(var k=0;k<=N;k++){ var ang=k/N*2*Math.PI; var s2=w2s(c.x+rad*Math.cos(ang), c.y+rad*Math.sin(ang)); if(k===0) ctx.moveTo(s2.x,s2.y); else ctx.lineTo(s2.x,s2.y); }
        } else {
          for(var j=0;j<pts.length;j++){ var s3=w2s(pts[j].x,pts[j].y); if(j===0) ctx.moveTo(s3.x,s3.y); else ctx.lineTo(s3.x,s3.y); }
          if(A.preview){ var s4=w2s(A.preview.x,A.preview.y); ctx.lineTo(s4.x,s4.y); }
        }
        ctx.stroke(); ctx.setLineDash([]);
      }
    }

    // Crosshair
    function drawCrosshair(){
      if(!state.cursor.big) return;
      var x=state.mouse.x, y=state.mouse.y;
      ctx.save();
      ctx.setLineDash([]);
      ctx.lineWidth=1;
      ctx.strokeStyle='rgba(173, 197, 255, 0.7)';
      ctx.beginPath();
      ctx.moveTo(0,y+0.5); ctx.lineTo(canvas.width/dpr, y+0.5);
      ctx.moveTo(x+0.5,0); ctx.lineTo(x+0.5, canvas.height/dpr);
      ctx.stroke();
      var r=state.cursor.pick;
      ctx.strokeStyle='rgba(173, 197, 255, 0.9)';
      ctx.strokeRect(Math.round(x-r)+0.5, Math.round(y-r)+0.5, r*2, r*2);
      ctx.restore();
    }

    // Snapping (includes block refs)
    function getSnap(wx,wy,sx,sy, override){
      var ap=12; var best=null, bestD=1e9;
      function trySnap(x,y,kind){
        var s=w2s(x,y); var dx=s.x-sx, dy=s.y-sy; var d=hypot2(dx,dy);
        if(d<=ap && d<bestD){ bestD=d; best={x:x,y:y,kind:kind}; }
      }
      var i,j,e;
      if((state.snaps.ends && !override) || override==='end'){
        for(i=0;i<state.drawing.entities.length;i++){
          e=state.drawing.entities[i]; if(!entVisible(e)) continue;
          if(e.type==='blockref'){ snapBlockEnds(e, trySnap); }
          else { for(j=0;j<e.pts.length;j++){ trySnap(e.pts[j].x, e.pts[j].y, 'end'); } }
        }
      }
      if((state.snaps.mids && !override) || override==='mid'){
        for(i=0;i<state.drawing.entities.length;i++){
          e=state.drawing.entities[i]; if(!entVisible(e)) continue;
          if(e.type==='blockref'){ snapBlockMids(e, trySnap); }
          else { for(j=0;j<e.pts.length-1;j++){ trySnap((e.pts[j].x+e.pts[j+1].x)/2, (e.pts[j].y+e.pts[j+1].y)/2, 'mid'); } }
        }
      }
      if(((state.snaps.inters && !override) || override==='int')){
        var segs = collectNearSegments(sx,sy,14);
        for(var a=0;a<segs.length;a++){
          for(var b=a+1;b<segs.length;b++){
            var P = segIntersect(segs[a].a, segs[a].b, segs[b].a, segs[b].b);
            if(P) trySnap(P.x, P.y, 'int');
          }
        }
      }
      if(state.snaps.grid && !override){
        var step=state.grid.step; trySnap(Math.round(wx/step)*step, Math.round(wy/step)*step, 'grid');
      }
      return best;
    }
    function collectNearSegments(sx,sy,pix){
      var res=[], i,j,e,a,b,sa,sb,d;
      for(i=0;i<state.drawing.entities.length;i++){
        e=state.drawing.entities[i]; if(!entVisible(e)) continue;
        if(e.type==='blockref'){ collectBlockSegments(e,res,sx,sy,pix); continue; }
        for(j=0;j<e.pts.length-1;j++){
          a=e.pts[j]; b=e.pts[j+1];
          sa=w2s(a.x,a.y); sb=w2s(b.x,b.y);
          d = distToSeg({x:sx,y:sy}, sa, sb);
          if(d<=pix) res.push({a:a, b:b});
        }
      }
      return res;
    }
    function collectBlockSegments(br,res,sx,sy,pix){
      var blk=state.blocks[br.ref]; if(!blk) return;
      var ang=(br.rot||0)*Math.PI/180, sc=br.scale||1, cos=Math.cos(ang), sin=Math.sin(ang);
      function T(pt){ var x=(pt.x - blk.base.x)*sc, y=(pt.y - blk.base.y)*sc; return {x: br.pos.x + x*cos - y*sin, y: br.pos.y + x*sin + y*cos}; }
      for(var i=0;i<blk.entities.length;i++){
        var e=blk.entities[i]; if(e.type!=='poly') continue;
        for(var j=0;j<e.pts.length-1;j++){
          var a=T(e.pts[j]), b=T(e.pts[j+1]), sa=w2s(a.x,a.y), sb=w2s(b.x,b.y);
          var d=distToSeg({x:sx,y:sy},sa,sb);
          if(d<=pix) res.push({a:a,b:b});
        }
      }
    }
    function distToSeg(p,a,b){
      var vx=b.x-a.x, vy=b.y-a.y;
      var wx=p.x-a.x, wy=p.y-a.y;
      var c1=vx*wx+vy*wy;
      if(c1<=0) return Math.sqrt(wx*wx+wy*wy);
      var c2=vx*vx+vy*vy;
      if(c2<=c1) return Math.sqrt((p.x-b.x)*(p.x-b.x)+(p.y-b.y)*(p.y-b.y));
      var t=c1/c2;
      var qx=a.x+t*vx, qy=a.y+t*vy;
      return Math.sqrt((p.x-qx)*(p.x-qx)+(p.y-qy)*(p.y-qy));
    }
    function segIntersect(a1,a2,b1,b2){
      var x1=a1.x, y1=a1.y, x2=a2.x, y2=a2.y;
      var x3=b1.x, y3=b1.y, x4=b2.x, y4=b2.y;
      var den=(x1-x2)*(y3-y4)-(y1-y2)*(x3-x4);
      if(Math.abs(den)<1e-9) return null;
      var px=((x1*y2 - y1*x2)*(x3 - x4) - (x1 - x2)*(x3*y4 - y3*x4))/den;
      var py=((x1*y2 - y1*x2)*(y3 - y4) - (y1 - y2)*(x3*y4 - y3*x4))/den;
      function within(x,a,b){ var min=Math.min(a,b)-1e-6, max=Math.max(a,b)+1e-6; return x>=min && x<=max; }
      if(within(px,x1,x2) && within(py,y1,y2) && within(px,x3,x4) && within(py,y3,y4)) return {x:px,y:py};
      return null;
    }
    function snapBlockEnds(br, cb){
      var blk=state.blocks[br.ref]; if(!blk) return;
      var ang=(br.rot||0)*Math.PI/180, sc=br.scale||1, cos=Math.cos(ang), sin=Math.sin(ang);
      function T(pt){ var x=(pt.x - blk.base.x)*sc, y=(pt.y - blk.base.y)*sc; return {x: br.pos.x + x*cos - y*sin, y: br.pos.y + x*sin + y*cos}; }
      for(var i=0;i<blk.entities.length;i++){
        var e=blk.entities[i]; if(e.type!=='poly') continue;
        for(var j=0;j<e.pts.length;j++){ var p=T(e.pts[j]); cb(p.x,p.y,'end'); }
      }
    }
    function snapBlockMids(br, cb){
      var blk=state.blocks[br.ref]; if(!blk) return;
      var ang=(br.rot||0)*Math.PI/180, sc=br.scale||1, cos=Math.cos(ang), sin=Math.sin(ang);
      function T(pt){ var x=(pt.x - blk.base.x)*sc, y=(pt.y - blk.base.y)*sc; return {x: br.pos.x + x*cos - y*sin, y: br.pos.y + x*sin + y*cos}; }
      for(var i=0;i<blk.entities.length;i++){
        var e=blk.entities[i]; if(e.type!=='poly') continue;
        for(var j=0;j<e.pts.length-1;j++){ var a=T(e.pts[j]), b=T(e.pts[j+1]); cb((a.x+b.x)/2,(a.y+b.y)/2,'mid'); }
      }
    }

    // Selection helpers
    function clearSelection(){ state.drawing.selection={}; updateSelInfo(); }
    function setSelected(i, on){ if(on) state.drawing.selection[i]=true; else delete state.drawing.selection[i]; updateSelInfo(); }
    function selectionIndices(){ var out=[]; for(var k in state.drawing.selection){ if(state.drawing.selection.hasOwnProperty(k)) out.push(parseInt(k,10)); } return out.sort(function(a,b){return a-b;}); }
    function updateSelInfo(){ var count=selectionIndices().length; document.getElementById('selInfo').textContent = count; }

    // Dynamic HUD (length/angle)
    function enableDyn(base){ state.dyn.active=true; state.dyn.field='len'; state.dyn.lenStr=''; state.dyn.angStr=''; state.dyn.lastBase=base; hud.style.display='block'; hudLen.className='active'; hudAng.className=''; }
    function disableDyn(){ state.dyn.active=false; hud.style.display='none'; }
    function parseDyn(){ var len=parseFloat(state.dyn.lenStr); var ang=parseFloat(state.dyn.angStr); return {len:isFinite(len)?len:null, ang:isFinite(ang)?ang:null}; }
    function applyDynFrom(base, raw){
      var d=parseDyn();
      var px=raw.x, py=raw.y;
      if(d.ang!=null && d.len!=null){ var rad=d.ang*Math.PI/180; px = base.x + d.len*Math.cos(rad); py = base.y + d.len*Math.sin(rad); }
      else if(d.len!=null){ var vx=raw.x-base.x, vy=raw.y-base.y; var L=hypot2(vx,vy)||1; px = base.x + d.len*(vx/L); py = base.y + d.len*(vy/L); }
      else if(d.ang!=null){ var rad2=d.ang*Math.PI/180; var L2=hypot2(raw.x-base.x, raw.y-base.y); px = base.x + L2*Math.cos(rad2); py = base.y + L2*Math.sin(rad2); }
      return {x:px,y:py};
    }
    function updateHUD(snap){
      var rect = canvas.getBoundingClientRect();
      var x=state.mouse.x+14, y=state.mouse.y+14;
      hud.style.left = Math.min(rect.width-160, Math.max(0,x))+'px';
      hud.style.top = Math.min(rect.height-90, Math.max(0,y))+'px';
      var base = state.dyn.lastBase;
      var cur = {x:state.mouse.wx, y:state.mouse.wy};
      if(snap){ cur={x:snap.x,y:snap.y}; }
      if(base){
        var dx=cur.x-base.x, dy=cur.y-base.y;
        var len=hypot2(dx,dy), ang=Math.atan2(dy,dx)*180/Math.PI;
        hudDXDY.textContent = fmt(dx)+','+fmt(dy);
        hudLen.textContent = state.dyn.lenStr===''? fmt(len) : state.dyn.lenStr;
        hudAng.textContent = state.dyn.angStr===''? fmt(ang) : state.dyn.angStr;
      } else { hudDXDY.textContent='—'; hudLen.textContent='—'; hudAng.textContent='—'; }
      hudSnap.textContent = snap? snap.kind : '—';
      hud.style.display = (state.dyn.active && (state.mode==='line' || state.mode==='poly' || state.mode==='rect' || state.mode==='circle'))? 'block':'none';
    }

    // Input handling
    var isPanning=false, panX0=0, panY0=0, ox0=0, oy0=0;
    canvas.addEventListener('contextmenu', function(e){ e.preventDefault(); return false; });

    canvas.addEventListener('mousedown', function(e){
      var rect=canvas.getBoundingClientRect();
      var x=e.clientX-rect.left, y=e.clientY-rect.top;
      var w=s2w(x,y);
      state.mouse.x=x; state.mouse.y=y; state.mouse.wx=w.x; state.mouse.wy=w.y;

      if(e.button===1 || e.button===2 || state.mode==='pan'){ isPanning=true; panX0=x; panY0=y; ox0=state.ox; oy0=state.oy; return; }

      if(state.mode==='select'){
        var idx=hitEntityAt(x,y);
        if(idx!==-1){ if(!e.shiftKey) clearSelection(); setSelected(idx, !state.drawing.selection[idx]); draw(); }
        else { state.action={type:'box', x0:x,y0:y,x1:x,y1:y}; }
        return;
      }

      if(state.mode==='line' || state.mode==='poly'){
        if(!state.action){ state.action={type: state.mode==='line'? 'drawLine':'drawPoly', pts: []}; enableDyn({x:w.x,y:w.y}); }
        var s=getSnap(w.x,w.y,x,y,state.pickOverride);
        var raw = s? {x:s.x,y:s.y} : {x:w.x,y:w.y};
        var pt = applyDynFrom(state.dyn.lastBase||raw, raw);
        if(state.action.pts.length===0) state.dyn.lastBase=pt;
        if(state.ortho && state.action.pts.length){ pt=applyOrtho(state.action.pts[state.action.pts.length-1], pt); }
        state.action.pts.push(pt); state.dyn.lastBase=pt; state.pickOverride=null; draw(); return;
      }
      if(state.mode==='rect'){
        if(!state.action){ state.action={type:'drawRect', pts:[{x:w.x,y:w.y}]}; enableDyn(state.action.pts[0]); draw(); return; }
        var rawR={x:w.x,y:w.y}; var ptR=applyDynFrom(state.dyn.lastBase||rawR, rawR);
        state.action.pts[1]=ptR;
        var a=state.action.pts[0], b=state.action.pts[1];
        var r=[{x:a.x,y:a.y},{x:b.x,y:a.y},{x:b.x,y:b.y},{x:a.x,y:b.y}];
        snapshot(); state.drawing.entities.push({type:'poly', pts:r, closed:true, layer:state.currentLayer}); state.action=null; disableDyn(); draw(); return;
      }
      if(state.mode==='circle'){
        if(!state.action){ state.action={type:'drawCircle', pts:[{x:w.x,y:w.y}]}; enableDyn(state.action.pts[0]); draw(); return; }
        var cen=state.action.pts[0];
        var rawC={x:w.x,y:w.y}; var ptC=applyDynFrom(state.dyn.lastBase||cen, rawC);
        var rad=hypot2(ptC.x-cen.x, ptC.y-cen.y);
        snapshot(); addCircleAsPoly(cen,rad, state.currentLayer, null); state.action=null; disableDyn(); draw(); return;
      }
    });
    window.addEventListener('dblclick', function(e){
      if(state.action && state.action.type==='drawPoly' && state.action.pts.length>=2){
        snapshot(); state.drawing.entities.push({type:'poly', pts:state.action.pts.slice(0), closed:false, layer:state.currentLayer}); state.action=null; disableDyn(); draw();
      }
    });
    window.addEventListener('mousemove', function(e){
      var rect=canvas.getBoundingClientRect();
      var x=e.clientX-rect.left, y=e.clientY-rect.top;
      var w=s2w(x,y);
      state.mouse.x=x; state.mouse.y=y; state.mouse.wx=w.x; state.mouse.wy=w.y;

      if(isPanning){ state.ox = ox0 + (x - panX0); state.oy = oy0 + (y - panY0); draw(); return; }

      if(state.action && state.action.type==='box'){
        state.action.x1=x; state.action.y1=y;
        var xMin=Math.min(state.action.x0,state.action.x1), xMax=Math.max(state.action.x0,state.action.x1);
        var yMin=Math.min(state.action.y0,state.action.y1), yMax=Math.max(state.action.y0,state.action.y1);
        clearSelection();
        for(var i=0;i<state.drawing.entities.length;i++){
          var e2=state.drawing.entities[i]; if(!entVisible(e2)) continue;
          var inside=true;
          if(e2.type==='poly'){
            for(var j=0;j<e2.pts.length;j++){ var s2=w2s(e2.pts[j].x,e2.pts[j].y); if(s2.x<xMin||s2.x>xMax||s2.y<yMin||s2.y>yMax){ inside=false; break; } }
          } else if(e2.type==='blockref'){
            var sb=w2s(e2.pos.x,e2.pos.y); inside = !(sb.x<xMin||sb.x>xMax||sb.y<yMin||sb.y>yMax);
          }
          if(inside) setSelected(i,true);
        }
        draw(); return;
      }

      if(state.action && state.action.type && state.action.type.indexOf('draw')===0){
        var base = state.action.pts.length? state.action.pts[state.action.pts.length-1] : null;
        var s=getSnap(w.x,w.y,x,y,state.pickOverride);
        var raw = s? {x:s.x,y:s.y} : {x:w.x,y:w.y};
        var pt = applyDynFrom(state.dyn.lastBase||raw, raw);
        if(state.ortho && base){ pt=applyOrtho(base, pt); }
        state.action.preview=pt; draw(); return;
      }
      draw();
    });
    window.addEventListener('mouseup', function(e){ isPanning=false; if(state.action && state.action.type==='box'){ state.action=null; draw(); } });

    // Mouse wheel zoom
    canvas.addEventListener('wheel', function(e){
      e.preventDefault();
      var rect=canvas.getBoundingClientRect(); var x=e.clientX-rect.left, y=e.clientY-rect.top; var before=s2w(x,y);
      var delta = e.deltaY || e.wheelDelta || 0;
      var factor = Math.exp(-(delta)*0.15/100);
      state.scale=clamp(state.scale*factor, 0.1, 20);
      var after=w2s(before.x,before.y);
      state.ox += (x-after.x); state.oy += (y-after.y);
      draw();
    }, {passive:false});

    // Hit tests
    function hitEntityAt(sx,sy){
      var tol=10; var best=-1, bestD=1e9;
      for(var i=0;i<state.drawing.entities.length;i++){
        var e=state.drawing.entities[i]; if(!entVisible(e)) continue;
        if(e.type==='blockref'){
          var s=w2s(e.pos.x,e.pos.y);
          var d=hypot2(sx-s.x, sy-s.y);
          if(d<tol && d<bestD){ bestD=d; best=i; }
          continue;
        }
        for(var j=0;j<e.pts.length-1;j++){
          var a=w2s(e.pts[j].x,e.pts[j].y), b=w2s(e.pts[j+1].x,e.pts[j+1].y);
          var d2=distToSeg({x:sx,y:sy},a,b);
          if(d2<tol && d2<bestD){ bestD=d2; best=i; }
        }
      }
      return best;
    }

    // Commands / keyboard
    var cmdInput = document.getElementById('cmdInput');
    function setMode(m){ state.mode=m; document.getElementById('modeLbl').textContent=m.charAt(0).toUpperCase()+m.slice(1); draw(); }
    function activateBtn(id){ var btns=document.querySelectorAll('#toolbox button'); for(var i=0;i<btns.length;i++){ btns[i].classList.remove('active'); } var el=document.getElementById(id); if(el) el.classList.add('active'); }
    function startCmd(name){
      state.lastCmd=name;
      if(name==='line') { setMode('line'); activateBtn('tb-line'); cmdInput.value=''; return; }
      if(name==='pline'){ setMode('poly'); activateBtn('tb-poly'); cmdInput.value=''; return; }
      if(name==='rect'){ setMode('rect'); activateBtn('tb-rect'); cmdInput.value=''; return; }
      if(name==='circle'){ setMode('circle'); activateBtn('tb-circle'); cmdInput.value=''; return; }
      if(name==='erase'){ eraseSelection(); cmdInput.value=''; return; }
      if(name==='zoom'){ state.action={type:'zoomwin', stage:0}; activateBtn('tb-zoom-win'); return; }
      if(name==='bmake'){ doMakeBlock(); return; }
      if(name==='bins'){ doInsertBlock(); return; }
      if(name==='explode'){ explodeSelected(); return; }
    }
    function eraseSelection(){ var idxs=selectionIndices(); if(!idxs.length) return; snapshot(); var keep=[]; for(var i=0;i<state.drawing.entities.length;i++){ if(state.drawing.selection[i]) continue; keep.push(state.drawing.entities[i]); } state.drawing.entities=keep; clearSelection(); draw(); }

    // Toolbar
    document.getElementById('tb-select').onclick=function(){ setMode('select'); activateBtn('tb-select'); state.action=null; disableDyn(); };
    document.getElementById('tb-line').onclick=function(){ startCmd('line'); };
    document.getElementById('tb-poly').onclick=function(){ startCmd('pline'); };
    document.getElementById('tb-rect').onclick=function(){ startCmd('rect'); };
    document.getElementById('tb-circle').onclick=function(){ startCmd('circle'); };
    document.getElementById('tb-erase').onclick=function(){ startCmd('erase'); };
    document.getElementById('tb-pan').onclick=function(){ setMode('pan'); activateBtn('tb-pan'); };
    document.getElementById('tb-zoom-win').onclick=function(){ state.action={type:'zoomwin',stage:0}; activateBtn('tb-zoom-win'); };
    document.getElementById('tb-zoom-ext').onclick=function(){ zoomExtents(); };
    document.getElementById('tb-zoom-prev').onclick=function(){ zoomPrevious(); };
    document.getElementById('tb-make-block').onclick=function(){ startCmd('bmake'); };
    document.getElementById('tb-insert-block').onclick=function(){ startCmd('bins'); };
    document.getElementById('tb-explode').onclick=function(){ startCmd('explode'); };

    // Header wires
    document.getElementById('openBtn').onclick=function(){ document.getElementById('fileInput').click(); };
    document.getElementById('saveBtn').onclick=function(){ saveJSON(); };
    document.getElementById('saveDxfBtn').onclick=function(){ saveDXF(); };
    document.getElementById('fileInput').addEventListener('change', onOpenFile);
    document.getElementById('showGrid').addEventListener('change', function(e){ state.showGrid=e.target.checked; draw(); });
    document.getElementById('snapGrid').addEventListener('change', function(e){ state.snaps.grid=e.target.checked; draw(); });
    document.getElementById('snapEnds').addEventListener('change', function(e){ state.snaps.ends=e.target.checked; draw(); });
    document.getElementById('snapMids').addEventListener('change', function(e){ state.snaps.mids=e.target.checked; draw(); });
    document.getElementById('snapInters').addEventListener('change', function(e){ state.snaps.inters=e.target.checked; draw(); });
    document.getElementById('orthoLock').addEventListener('change', function(e){ state.ortho=e.target.checked; });
    document.getElementById('gridStep').addEventListener('change', function(e){ var v=parseFloat(e.target.value); if(isFinite(v)&&v>0) state.grid.step=v; draw(); });
    document.getElementById('forceRedraw').onclick=function(){ setCanvasSize(); draw(); };
    document.getElementById('resetView').onclick=function(){ var r=canvas.getBoundingClientRect(); state.scale=1; state.ox=r.width/2; state.oy=r.height/2; draw(); };
    document.getElementById('bigCross').addEventListener('change', function(e){ state.cursor.big=e.target.checked; draw(); });
    document.getElementById('pickSize').addEventListener('change', function(e){ var v=parseFloat(e.target.value); if(isFinite(v)&&v>0) state.cursor.pick=v; draw(); });

    // Layers UI
    function rebuildLayerUI(){
      var sel = document.getElementById('layerSelect');
      var propSel=document.getElementById('propLayer');
      sel.innerHTML=''; propSel.innerHTML='';
      for(var i=0;i<state.layers.length;i++){
        var opt=document.createElement('option'); opt.value=state.layers[i].name; opt.textContent=state.layers[i].name + (state.layers[i].visible===false?' (hidden)':''); sel.appendChild(opt);
        var opt2=document.createElement('option'); opt2.value=state.layers[i].name; opt2.textContent=state.layers[i].name; propSel.appendChild(opt2);
      }
      sel.value=state.currentLayer; propSel.value=state.currentLayer;
    }
    function ensureLayer(name, color){
      for(var i=0;i<state.layers.length;i++){ if(state.layers[i].name===name) return state.layers[i]; }
      var L={name:name||'0', color:color||'#e0e6ff', visible:true}; state.layers.push(L); rebuildLayerUI(); return L;
    }
    function ensureLayersFromEntities(){
      var seen={};
      for(var i=0;i<state.drawing.entities.length;i++){ seen[state.drawing.entities[i].layer||'0']=true; }
      for(var k in seen){ if(seen.hasOwnProperty(k)) ensureLayer(k); }
    }
    document.getElementById('layerSelect').addEventListener('change', function(e){ state.currentLayer=e.target.value; });
    document.getElementById('addLayerBtn').onclick=function(){
      var name=document.getElementById('newLayerName').value || ('Layer'+(state.layers.length));
      var color=document.getElementById('newLayerColor').value || '#e0e6ff';
      ensureLayer(name, color); state.currentLayer=name; rebuildLayerUI();
    };
    document.getElementById('toggleLayerBtn').onclick=function(){
      var cur=currentLayerObj(); if(!cur) return; cur.visible = !cur.visible; rebuildLayerUI(); draw();
    };
    document.getElementById('delLayerBtn').onclick=function(){
      if(state.currentLayer==='0') return;
      var keep=[];
      for(var i=0;i<state.layers.length;i++){ if(state.layers[i].name!==state.currentLayer) keep.push(state.layers[i]); }
      for(var j=0;j<state.drawing.entities.length;j++){ if(state.drawing.entities[j].layer===state.currentLayer) state.drawing.entities[j].layer='0'; }
      state.layers=keep; state.currentLayer='0'; rebuildLayerUI(); draw();
    };
    document.getElementById('applyProps').onclick=function(){
      var newLayer=document.getElementById('propLayer').value;
      var newColor=document.getElementById('propColor').value;
      ensureLayer(newLayer);
      var idxs=selectionIndices(); if(!idxs.length) return;
      snapshot();
      for(var i=0;i<idxs.length;i++){ var e=state.drawing.entities[idxs[i]]; e.layer=newLayer; e.color=newColor; }
      draw();
    };

    // Blocks UI
    function rebuildBlockUI(){
      var list=document.getElementById('blockList'); list.innerHTML='';
      for(var k in state.blocks){ if(state.blocks.hasOwnProperty(k)){ var o=document.createElement('option'); o.value=k; o.textContent=k; list.appendChild(o);} }
    }
    function firstSelectedPoint(){
      var idxs=selectionIndices(); if(!idxs.length) return null;
      var e=state.drawing.entities[idxs[0]];
      if(e.type==='poly'){ return e.pts[0]; }
      if(e.type==='blockref'){ return e.pos; }
      return null;
    }
    function doMakeBlock(){
      var idxs=selectionIndices(); if(!idxs.length){ alert('Select polyline entities to block.'); return; }
      var name=(document.getElementById('blockName').value||'Block') + '';
      var base=state.dyn.lastBase || firstSelectedPoint() || {x:0,y:0};
      var ents=[], i,j, e, pts;
      for(i=0;i<idxs.length;i++){
        e=state.drawing.entities[idxs[i]];
        if(e.type==='poly'){
          pts=[]; for(j=0;j<e.pts.length;j++){ pts.push({x:e.pts[j].x,y:e.pts[j].y}); }
          ents.push({type:'poly', pts:pts, closed:e.closed, layer:e.layer, color:e.color});
        }
      }
      if(!ents.length){ alert('Only polylines supported for blocks in this version.'); return; }
      state.blocks[name]={name:name, base:{x:base.x,y:base.y}, entities:ents};
      rebuildBlockUI();
    }
    function doInsertBlock(){
      var name=(document.getElementById('blockList').value||document.getElementById('blockName').value||'').trim();
      if(!name || !state.blocks[name]){ alert('Choose a block from Library or enter a valid name.'); return; }
      state.action={type:'insertBlock', name:name, stage:0};
      var once=function(ev){
        canvas.removeEventListener('click', once);
        var rect=canvas.getBoundingClientRect();
        var x=ev.clientX-rect.left, y=ev.clientY-rect.top; var w=s2w(x,y);
        snapshot();
        state.drawing.entities.push({type:'blockref', ref:name, pos:{x:w.x,y:w.y}, rot:0, scale:1, layer:state.currentLayer});
        state.action=null; draw();
      };
      canvas.addEventListener('click', once);
    }
    function explodeSelected(){
      var idxs=selectionIndices(); if(!idxs.length) return;
      snapshot();
      var add=[], keep=[];
      for(var i=0;i<state.drawing.entities.length;i++){
        var e=state.drawing.entities[i];
        if(state.drawing.selection[i] && e.type==='blockref'){
          var blk=state.blocks[e.ref]; if(!blk) continue;
          var ang=(e.rot||0)*Math.PI/180, sc=e.scale||1, cos=Math.cos(ang), sin=Math.sin(ang);
          function T(pt){ var x=(pt.x-blk.base.x)*sc, y=(pt.y-blk.base.y)*sc; return {x:e.pos.x + x*cos - y*sin, y:e.pos.y + x*sin + y*cos}; }
          for(var k=0;k<blk.entities.length;k++){
            var pe=blk.entities[k]; if(pe.type!=='poly') continue;
            var pts=[]; for(var j=0;j<pe.pts.length;j++){ var p=T(pe.pts[j]); pts.push({x:p.x,y:p.y}); }
            add.push({type:'poly', pts:pts, closed:pe.closed, layer:e.layer, color:e.color || pe.color});
          }
        } else { keep.push(e); }
      }
      state.drawing.entities=keep.concat(add);
      clearSelection(); draw();
    }

    // File IO
    function download(name, text){
      var a=document.createElement('a');
      a.href='data:text/plain;charset=utf-8,' + encodeURIComponent(text);
      a.download=name; a.click();
    }
    function saveJSON(){
      var payload={entities:state.drawing.entities, layers:state.layers, currentLayer:state.currentLayer, blocks:state.blocks};
      download('drawing.json', JSON.stringify(payload));
    }
    function saveDXF(){ var dxf=toDXF(explodedEntities()); download('drawing.dxf', dxf); }
    function explodedEntities(){
      var ents=[];
      for(var i=0;i<state.drawing.entities.length;i++){
        var e=state.drawing.entities[i];
        if(e.type==='poly'){ ents.push(e); }
        else if(e.type==='blockref'){
          var blk=state.blocks[e.ref]; if(!blk) continue;
          var ang=(e.rot||0)*Math.PI/180, sc=e.scale||1, cos=Math.cos(ang), sin=Math.sin(ang);
          function T(pt){ var x=(pt.x-blk.base.x)*sc, y=(pt.y-blk.base.y)*sc; return {x:e.pos.x + x*cos - y*sin, y:e.pos.y + x*sin + y*cos}; }
          for(var k=0;k<blk.entities.length;k++){
            var pe=blk.entities[k]; if(pe.type!=='poly') continue;
            var pts=[]; for(var j=0;j<pe.pts.length;j++){ var p=T(pe.pts[j]); pts.push({x:p.x,y:p.y}); }
            ents.push({type:'poly', pts:pts, closed:pe.closed, layer:e.layer, color:e.color || pe.color});
          }
        }
      }
      return ents;
    }
    function toDXF(entities){
      var out=''; function w(code,val){ out+=code+'\\n'+String(val)+'\\n'; }
      w(0,'SECTION'); w(2,'HEADER'); w(9,'$ACADVER'); w(1,'AC1009'); w(0,'ENDSEC');
      w(0,'SECTION'); w(2,'ENTITIES');
      for(var i=0;i<entities.length;i++){
        var e=entities[i];
        if(e.type==='poly'){
          for(var j=0;j<e.pts.length-1;j++){
            var a=e.pts[j], b=e.pts[j+1];
            w(0,'LINE'); w(8, e.layer || '0');
            w(10,a.x); w(20,a.y); w(30,0); w(11,b.x); w(21,b.y); w(31,0);
          }
          if(e.closed && e.pts.length>1){
            var a2=e.pts[e.pts.length-1], b2=e.pts[0];
            w(0,'LINE'); w(8,e.layer||'0');
            w(10,a2.x); w(20,a2.y); w(30,0); w(11,b2.x); w(21,b2.y); w(31,0);
          }
        }
      }
      w(0,'ENDSEC'); w(0,'EOF'); return out;
    }
    function onOpenFile(e){
      var file=e.target.files[0]; if(!file) return;
      var name=file.name.toLowerCase();
      var rd=new FileReader();
      rd.onload=function(){
        try{
          var text=rd.result;
          if(name.indexOf('.json')>=0){
            var data=JSON.parse(text);
            if(data.layers){ state.layers=data.layers; state.currentLayer=data.currentLayer||'0'; }
            state.blocks=data.blocks||{};
            state.drawing.entities=Array.isArray(data.entities)? data.entities: [];
            ensureLayersFromEntities(); rebuildLayerUI(); rebuildBlockUI(); clearSelection(); draw();
          } else if(name.indexOf('.dxf')>=0 || name.indexOf('.txt')>=0){
            var ents = parseDXF(text);
            state.drawing.entities = ents;
            ensureLayersFromEntities(); rebuildLayerUI(); rebuildBlockUI(); clearSelection(); draw();
          } else { alert('Unsupported file type.'); }
        }catch(err2){ showErr(err2.stack||err2); alert('Failed to open file: '+err2.message); }
      };
      rd.readAsText(file);
      e.target.value='';
    }
    function parseDXF(text){
      var lines = text.replace(/\r\n/g,'\n').split(/\n/);
      var pairs = [];
      for(var i=0;i<lines.length-1;i+=2){
        var code = lines[i].trim();
        var val = (lines[i+1]!==undefined) ? lines[i+1].replace(/\r/g,'') : '';
        if(code==='') continue;
        pairs.push([parseInt(code,10), val]);
      }
      var entities=[];
      var layer='0', inEntities=false;
      for(var k=0;k<pairs.length;k++){
        var c=pairs[k][0], v=pairs[k][1];
        if(c===0 && v==='SECTION' && pairs[k+1] && pairs[k+1][0]===2 && pairs[k+1][1]==='ENTITIES'){ inEntities=true; k++; continue; }
        if(c===0 && v==='ENDSEC'){ inEntities=false; continue; }
        if(!inEntities) continue;
        if(c===0 && v==='LINE'){
          var a={x:0,y:0}, b={x:0,y:0}; layer='0';
          for(var t=k+1;t<k+30 && t<pairs.length;t++){
            var cc=pairs[t][0], vv=pairs[t][1];
            if(cc===8) layer=vv;
            if(cc===10) a.x=parseFloat(vv);
            if(cc===20) a.y=parseFloat(vv);
            if(cc===11) b.x=parseFloat(vv);
            if(cc===21) b.y=parseFloat(vv);
            if(cc===0){ break; }
          }
          entities.push({type:'poly', pts:[a,b], layer:layer});
        }
      }
      return entities;
    }

    // Keyboard
    cmdInput.addEventListener('keydown', function(e){
      if(e.key==='Enter'){ handleCmdEnter(cmdInput.value); cmdInput.value=''; }
      if(e.key==='Escape'){ state.action=null; disableDyn(); }
      if(e.key===' ' && !cmdInput.value){ if(state.lastCmd) startCmd(state.lastCmd); e.preventDefault(); }
    });
    function handleCmdEnter(txt){
      var t=(txt||'').trim().toLowerCase();
      if(!t){ if(state.lastCmd) startCmd(state.lastCmd); return; }
      if(t==='l' || t==='line'){ startCmd('line'); return; }
      if(t==='pl' || t==='pline'){ startCmd('pline'); return; }
      if(t==='rec' || t==='rect' || t==='rectangle'){ startCmd('rect'); return; }
      if(t==='c' || t==='circle'){ startCmd('circle'); return; }
      if(t==='e' || t==='erase' || t==='del'){ startCmd('erase'); return; }
      if(t==='z' || t==='zoom'){ startCmd('zoom'); return; }
      if(t==='bmake' || t==='b'){ startCmd('bmake'); return; }
      if(t==='bins' || t==='i'){ startCmd('bins'); return; }
      if(t==='explode' || t==='x'){ startCmd('explode'); return; }
    }
    window.addEventListener('keydown', function(e){
      var tag=document.activeElement && document.activeElement.tagName ? document.activeElement.tagName.toLowerCase() : '';
      if(tag!=='input' && tag!=='textarea'){
        if(e.key && e.key.length===1 && !e.ctrlKey && !e.metaKey && !e.altKey){ cmdInput.value=e.key; cmdInput.focus(); try{ cmdInput.setSelectionRange(1,1); }catch(_e){} }
      }
      if((e.ctrlKey||e.metaKey) && (e.key==='z' || e.key==='Z')){ e.preventDefault(); undo(); }
      if((e.ctrlKey||e.metaKey) && (e.key==='y' || (e.shiftKey && (e.key==='Z' || e.key==='z')))){ e.preventDefault(); redo(); }
      if((e.ctrlKey||e.metaKey) && (e.key==='s' || e.key==='S')){ e.preventDefault(); saveJSON(); }
      if((e.ctrlKey||e.metaKey) && (e.key==='o' || e.key==='O')){ e.preventDefault(); document.getElementById('fileInput').click(); }
      if(e.key==='F8'){ state.ortho=!state.ortho; document.getElementById('orthoLock').checked=state.ortho; }
      if(e.key==='v' || e.key==='V'){ setMode('select'); activateBtn('tb-select'); }
      if(e.key==='l' || e.key==='L'){ setMode('line'); activateBtn('tb-line'); }
      if(e.key==='p' || e.key==='P'){ setMode('poly'); activateBtn('tb-poly'); }
      if(e.key==='b' || e.key==='B'){ startCmd('bmake'); }
      if(e.key==='i' || e.key==='I'){ startCmd('bins'); }
      if(e.key==='x' || e.key==='X'){ startCmd('explode'); }
      if(e.key==='e' || e.key==='E'){ if(document.activeElement!==cmdInput) startCmd('erase'); }
    });

    // Util zooms
    function zoomExtents(){
      if(!state.drawing.entities.length){ var r=canvas.getBoundingClientRect(); state.scale=1; state.ox=r.width/2; state.oy=r.height/2; draw(); return; }
      var minX=1e9,minY=1e9,maxX=-1e9,maxY=-1e9;
      var ents=explodedEntities();
      for(var i=0;i<ents.length;i++){
        var e=ents[i];
        for(var j=0;j<e.pts.length;j++){ var p=e.pts[j]; if(p.x<minX)minX=p.x; if(p.y<minY)minY=p.y; if(p.x>maxX)maxX=p.x; if(p.y>maxY)maxY=p.y; }
      }
      var rect=canvas.getBoundingClientRect();
      var pad=50;
      var w=maxX-minX, h=maxY-minY;
      if(w<=0 || h<=0){ draw(); return; }
      var sx=(rect.width-2*pad)/w, sy=(rect.height-2*pad)/h;
      state.scale=Math.max(0.1, Math.min(10, Math.min(sx,sy)));
      var cX=(minX+maxX)/2, cY=(minY+maxY)/2;
      var s=w2s(cX,cY);
      state.ox += rect.width/2 - s.x;
      state.oy += rect.height/2 - s.y;
      draw();
    }
    function zoomPrevious(){ if(state.viewPrev){ var v=state.viewPrev; state.scale=v.scale; state.ox=v.ox; state.oy=v.oy; draw(); } }

    // Init
    function rebuildAll(){ rebuildLayerUI(); rebuildBlockUI(); }
    rebuildAll();
    window.addEventListener('resize', setCanvasSize);
    requestAnimationFrame(function(){ setCanvasSize(); });
    okPill.textContent='Loaded ✓';
    okPill.style.background='#10331c';
    okPill.style.borderColor='#1f5a32';
  }catch(ex){ showErr(ex.stack||ex); }
})();
</script>
</body>
</html>

