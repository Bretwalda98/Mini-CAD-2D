<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Mini-CAD 2D — AutoCAD-Style UI</title>
<style>
  :root{
    --bg:#0b0e14; --panel:#121625; --ink:#e8ecf1; --muted:#9aa4b2; --accent:#4da3ff; --accent2:#47e5a1;
    --grid-minor:#2e344a; --grid-major:#4f5b88; --axis:#7aa2ff; --sel:#7aa2ff33; --hud:#0e1628cc; --hud-border:#2a3a70;
    --bar:#0f1426; --bar2:#0b1021; --stroke:#1e2335;
  }
  *{box-sizing:border-box}
  html,body{height:100%; margin:0; background:var(--bg); color:var(--ink); font-family:Arial,Helvetica,system-ui; overscroll-behavior:none}
  #app{
    height:100vh; display:grid;
    grid-template-rows: 36px 32px 40px 34px 1fr 28px 38px;
    grid-template-columns: 1fr;
    grid-template-areas:
      "appbar"
      "titlebar"
      "ribbon"
      "filetabs"
      "drawing"
      "modellayout"
      "status";
  }
  .bar{display:flex; align-items:center; gap:.4rem; padding:0 .5rem; border-bottom:1px solid var(--stroke)}
  #appbar{grid-area:appbar; background:var(--bar)}
  #titlebar{grid-area:titlebar; background:var(--bar2)}
  #ribbon{grid-area:ribbon; background:var(--panel); border-bottom:1px solid var(--stroke); overflow:hidden}
  #fileTabs{grid-area:filetabs; background:#0d1223; border-bottom:1px solid var(--stroke); display:flex; align-items:end; gap:.25rem; padding:0 .5rem}
  .app-button{width:28px; height:28px; background:#b61c1c; color:#fff; border:none; border-radius:4px; font-weight:700; cursor:pointer}
  .qat{display:flex; align-items:center; gap:.35rem; margin-left:.4rem}
  .qat button{height:26px; padding:0 .5rem; border:1px solid #263050; background:#171c2b; color:#e8ecf1; border-radius:.35rem; font-size:.85rem; cursor:pointer}
  .qat input[type=file]{display:none}
  .title-left{display:flex; align-items:center; gap:.5rem}
  .title-center{flex:1; text-align:center; font-weight:600}
  .title-right{display:flex; align-items:center; gap:.5rem}
  #searchAll{height:26px; background:#101425; color:#e6e6e6; border:1px solid #1e2436; border-radius:.35rem; padding:.25rem .45rem; min-width:240px}
  .info-icon{width:24px; height:24px; display:inline-grid; place-items:center; border:1px solid #243154; border-radius:.35rem; background:#151a31}
  .ribbon-tabs{display:flex; gap:.25rem; padding:.2rem .4rem; border-bottom:1px solid #202846}
  .ribbon-tab{padding:.25rem .6rem; font-size:.92rem; border-radius:.35rem .35rem 0 0; cursor:pointer; color:#cbd5f1}
  .ribbon-tab.active{background:#10162c; border:1px solid #243154; border-bottom:none}
  .ribbon-body{display:flex; gap:.75rem; padding:.5rem; overflow:auto}
  .group{background:#0f152c; border:1px solid #243154; border-radius:.5rem; padding:.45rem; min-width:180px}
  .group .gtitle{font-size:.75rem; color:#aab6d8; margin-top:.25rem}
  .grow{display:flex; flex-wrap:wrap; gap:.35rem}
  .tool-btn{min-width:44px; height:34px; background:#161c32; color:#dfe7ff; border:1px solid #2c3861; border-radius:.4rem; cursor:pointer; font-size:.8rem; padding:0 .5rem}
  .tool-btn.active{outline:2px solid var(--accent)}
  .file-tab{height:26px; display:flex; align-items:center; padding:0 .6rem; background:#151a31; color:#dce6ff; border:1px solid #273056; border-bottom:none; border-top-left-radius:.4rem; border-top-right-radius:.4rem}
  .file-tab.current{background:#10162c; font-weight:600}
  .file-tab .dirty{margin-left:.4rem; color:#f7c94b}
  .file-plus{margin-left:auto; height:24px; width:24px; display:grid; place-items:center; border:1px dashed #2a3358; border-radius:.35rem; cursor:pointer}
  #drawing{grid-area:drawing; position:relative; background:#0a0d16}
  canvas{display:block; width:100%; height:100%; background:transparent; touch-action:none; cursor:none}
  #ucs{position:absolute; left:10px; bottom:56px; width:64px; height:64px; border:1px solid #203050; border-radius:.5rem; background:#0d1326aa; display:grid; place-items:center; font:11px/1 monospace; color:#9ab3ff}
  #ucs::before{content:""; position:absolute; width:2px; height:24px; background:#89a7ff; bottom:12px; left:32px}
  #ucs::after{content:""; position:absolute; height:2px; width:24px; background:#89a7ff; bottom:32px; left:12px}
  #navBar{position:absolute; right:10px; top:10px; width:56px; display:flex; flex-direction:column; gap:.4rem}
  .nav-btn{height:40px; border:1px solid #2a3358; border-radius:.45rem; background:#0f1428cc; color:#e6eeff; cursor:pointer}
  #sideDrawer{position:absolute; right:72px; top:10px; bottom:56px; width:300px; background:#0f1426; border:1px solid #1e2335; border-radius:.6rem; padding:.6rem; overflow:auto; display:none}
  #sideDrawer h3{margin:.6rem 0 .4rem; font-size:1rem; color:#cfe3ff}
  #sideDrawer .row{display:flex; align-items:center; justify-content:space-between; margin:.25rem 0; gap:.4rem}
  #sideDrawer input[type="color"]{width:36px; height:24px; border:1px solid #2a3358; background:#0b0e14}
  #sideDrawer select, #sideDrawer input[type="text"], #sideDrawer input[type="number"]{flex:1; background:#101425; color:#e6e6e6; border:1px solid #1e2436; border-radius:.25rem; padding:.25rem .35rem}
  .hint{color:#94a3b8; font-size:12px; margin-top:.35rem}
  #hud{
    position:absolute; pointer-events:none; display:none;
    background:var(--hud); color:#e4eeff; border:1px solid var(--hud-border); border-radius:.4rem; padding:.25rem .35rem; font:12px/1.2 monospace; min-width:120px; z-index:8;
  }
  #hud .row{display:flex; justify-content:space-between; gap:.4rem}
  #hud .key{color:#9ab3ff}
  #hud .active{outline:1px dashed #7db6ff; outline-offset:2px; border-radius:.2rem; padding:0 2px;}
  #err{position:absolute; left:8px; bottom:56px; background:#330d10; color:#ffd7d7; border:1px solid #5a1e1e; padding:.4rem .5rem; border-radius:.4rem; font:12px/1.2 monospace; display:none; max-width:90vw; white-space:pre-wrap; z-index:50}
  #modelTabs{grid-area:modellayout; display:flex; align-items:center; gap:.25rem; padding:0 .5rem; background:#0e1324; border-top:1px solid #1a2040; border-bottom:1px solid #1a2040}
  .mltab{height:24px; display:flex; align-items:center; padding:0 .6rem; background:#151a31; color:#dce6ff; border:1px solid #273056; border-radius:.35rem; cursor:pointer}
  .mltab.active{background:#10162c; font-weight:600}
  #statusBar{grid-area:status; position:relative; display:flex; align-items:center; gap:.5rem; padding:0 .5rem; background:#0e1324; border-top:1px solid var(--stroke); color:#9aa4b2; font:14px/1.2 monospace}
  #cliWrap{position:absolute; left:50%; transform:translateX(-50%); display:flex; align-items:center; gap:.25rem}
  #cmdHistory{max-width:42vw; max-height:34px; overflow:hidden; color:#9db0cc}
  #cmdInput{width:360px; background:#0b0f1f; color:#f2f6ff; border:1px solid #263050; border-radius:.35rem; padding:.25rem .45rem; font:14px/1.2 monospace}
  .st-right{margin-left:auto; display:flex; align-items:center; gap:.35rem}
  .st-toggle{height:26px; display:inline-flex; align-items:center; gap:.35rem; padding:0 .45rem; border:1px solid #263050; background:#121a30; border-radius:.35rem; cursor:pointer; user-select:none}
  .st-toggle input{accent-color:#7aa2ff}
  .ctxmenu{position:absolute; z-index:9999; min-width:220px; background:#0f1426; border:1px solid #2a3358; border-radius:.4rem; box-shadow:0 10px 30px rgba(0,0,0,.4); color:#e6eeff; font:13px/1.35 system-ui,Arial; user-select:none}
  .ctxmenu.hidden{display:none}
  .ctxmenu .item{display:flex; align-items:center; justify-content:space-between; gap:.6rem; padding:.4rem .6rem; cursor:pointer}
  .ctxmenu .item:hover{background:#182142}
  .ctxmenu .item.disabled{opacity:.5; cursor:default}
  .ctxmenu .sep{height:1px; background:#1e2335; margin:.35rem 0}
  .ctxmenu .label{pointer-events:none}
  .ctxmenu .accel{opacity:.7; font-family:monospace}
  .ctxmenu .check{width:1rem; display:inline-block; text-align:center; opacity:.9}
  .ctxmenu .submenu::after{content:"▶"; opacity:.6; margin-left:.4rem}
  .ctxmenu .group{position:relative}
  .ctxmenu .group:hover > .submenu-panel{display:block}
  .ctxmenu .submenu-panel{display:none; position:absolute; top:-.4rem; left:100%; margin-left:.3rem; min-width:220px}
  .pill{padding:.1rem .4rem; border:1px solid #2a3046; border-radius:.4rem; background:#12182a; color:#fff}
  @media (max-width: 900px){
    #searchAll{min-width:140px}
    #cmdInput{width:230px}
    #sideDrawer{right:10px; width:85vw}
  }
</style>
</head>
<body>
<div id="app">
  <div id="appbar" class="bar">
    <button class="app-button" title="Application Menu">A</button>
    <div class="qat">
      <button id="openBtn" title="Open JSON/DXF (Ctrl+O)">Open</button>
      <button id="saveBtn" title="Save JSON (Ctrl+S)">Save</button>
      <button id="saveDxfBtn" title="Save As DXF">DXF</button>
      <button id="undoBtn" title="Undo (Ctrl+Z)">Undo</button>
      <button id="redoBtn" title="Redo (Ctrl+Y)">Redo</button>
      <input type="file" id="fileInput" accept=".json,.dxf,.txt" />
      <span id="okpill" class="pill">Ready ✓</span>
    </div>
  </div>

  <div id="titlebar" class="bar">
    <div class="title-left">
      <span class="pill">Home</span>
    </div>
    <div class="title-center" id="titleFile">Mini-CAD — Drawing1</div>
    <div class="title-right">
      <input id="searchAll" type="text" placeholder="Type a command (e.g., L, PL, REC…)" />
      <span class="info-icon" title="Settings">⚙</span>
      <span class="info-icon" title="Help">?</span>
    </div>
  </div>

  <div id="ribbon">
    <div class="ribbon-tabs">
      <div class="ribbon-tab active" data-tab="home">Home</div>
      <div class="ribbon-tab" data-tab="insert">Insert</div>
      <div class="ribbon-tab" data-tab="annotate">Annotate</div>
      <div class="ribbon-tab" data-tab="view">View</div>
      <div class="ribbon-tab" data-tab="manage">Manage</div>
      <div class="ribbon-tab" data-tab="express">Express</div>
      <div class="ribbon-tab" data-tab="properties">Properties</div>
    </div>
    <div class="ribbon-body" id="ribbonBody">
      <div class="group" data-group="draw">
        <div class="grow">
          <button class="tool-btn active" id="tb-select" title="Select (V)">Sel</button>
          <button class="tool-btn" id="tb-point"  title="Point (PO)">Point</button>
          <button class="tool-btn" id="tb-line"   title="Line (L)">Line</button>
          <button class="tool-btn" id="tb-arc"    title="Arc 3P (A)">Arc</button>
          <button class="tool-btn" id="tb-poly"   title="Polyline (PL)">Pline</button>
          <button class="tool-btn" id="tb-rect"   title="Rectangle (REC)">Rect</button>
          <button class="tool-btn" id="tb-circle" title="Circle (C)">Circ</button>
          <button class="tool-btn" id="tb-trace"  title="Trace (TR)">Trace</button>
          <button class="tool-btn" id="tb-text"   title="Text (T)">Text</button>
        </div>
        <div class="gtitle">Draw</div>
      </div>
      <div class="group" data-group="modify">
        <div class="grow">
          <button class="tool-btn" id="tb-erase"   title="Erase (E)">Erase</button>
          <button class="tool-btn" id="tb-mirror"  title="Mirror (MI)">Mirror</button>
          <button class="tool-btn" id="tb-offset"  title="Offset (O)">Offset</button>
          <button class="tool-btn" id="tb-stretch" title="Stretch (S)">Stretch</button>
          <button class="tool-btn" id="tb-chamfer" title="Chamfer (CHA)">Chamfer</button>
          <button class="tool-btn" id="tb-move"    title="Move (M)">Move</button>
          <button class="tool-btn" id="tb-copy"    title="Copy (CO)">Copy</button>
          <button class="tool-btn" id="tb-rotate"  title="Rotate (RO)">Rot</button>
          <button class="tool-btn" id="tb-scale"   title="Scale (SC)">Scale</button>
        </div>
        <div class="gtitle">Modify</div>
      </div>
      <div class="group" data-group="blocks">
        <div class="grow">
          <button class="tool-btn" id="tb-make-block"   title="Make Block (B)">BMake</button>
          <button class="tool-btn" id="tb-insert-block" title="Insert Block (I)">BIns</button>
          <button class="tool-btn" id="tb-explode"      title="Explode (X)">Explode</button>
        </div>
        <div class="gtitle">Blocks</div>
      </div>
      <div class="group" data-group="view">
        <div class="grow">
          <button class="tool-btn" id="tb-pan"       title="Pan (Middle/Right drag)">Pan</button>
          <button class="tool-btn" id="tb-zoom-win"  title="Zoom Window (Z→W)">ZWin</button>
          <button class="tool-btn" id="tb-zoom-prev" title="Zoom Previous (Z→P)">ZPrev</button>
          <button class="tool-btn" id="tb-zoom-ext"  title="Zoom Extents (Z→E)">ZExt</button>
        </div>
        <div class="gtitle">View</div>
      </div>
      <div class="group" data-group="utilities">
        <div class="grow">
          <button class="tool-btn" id="m2pBtn"      title="Mid Between 2 Points (M2P)">M2P</button>
          <button class="tool-btn" id="forceRedraw" title="Force Redraw">Redraw</button>
          <button class="tool-btn" id="resetView"   title="Reset View">Reset</button>
          <button class="tool-btn" id="toggleDrawer" title="Toggle Properties">Props</button>
        </div>
        <div class="gtitle">Utilities</div>
      </div>
    </div>
  </div>

  <div id="fileTabs">
    <div class="file-tab current">Start</div>
    <div class="file-tab current">Drawing1* <span class="dirty">•</span></div>
    <div class="file-plus" title="New drawing">＋</div>
  </div>

  <div id="drawing">
    <canvas id="c"></canvas>
    <div id="ucs">UCS</div>
    <div id="navBar">
      <button class="nav-btn" id="navZoomIn"  title="Zoom In">＋</button>
      <button class="nav-btn" id="navZoomOut" title="Zoom Out">－</button>
      <button class="nav-btn" id="navFit"     title="Zoom Extents">□</button>
      <button class="nav-btn" id="navPan"     title="Pan">↔</button>
    </div>
    <aside id="sideDrawer">
      <div id="panel">
        <h3>Layers</h3>
        <div class="row">
          <label for="layerSelect">Current</label>
          <select id="layerSelect"></select>
        </div>
        <div class="row">
          <input id="newLayerName" type="text" placeholder="New layer name" />
          <input id="newLayerColor" type="color" value="#e0e6ff" />
        </div>
        <div class="row">
          <button id="addLayerBtn">Add</button>
          <button id="toggleLayerBtn">Hide/Show</button>
          <button id="delLayerBtn">Delete</button>
        </div>
        <div class="hint">Entities remember their layer. Hidden layers don't render.</div>

        <h3>Blocks</h3>
        <div class="row">
          <label for="blockName">Name</label>
          <input id="blockName" type="text" placeholder="e.g., Door-900" />
        </div>
        <div class="row">
          <label for="blockList">Library</label>
          <select id="blockList"></select>
        </div>
        <div class="hint">Make a block from selection, set base point (last picked), then insert by name.</div>

        <h3>Properties</h3>
        <div id="propContent">
          <div class="row"><span>Selection:</span> <span id="selInfo">0</span></div>
          <div class="row">
            <label for="propLayer">Layer</label>
            <select id="propLayer"></select>
          </div>
          <div class="row">
            <label for="propColor">Color</label>
            <input id="propColor" type="color" value="#e0e6ff" />
          </div>
          <div class="row">
            <label for="propLtype">Linetype</label>
            <select id="propLtype">
              <option value="CONTINUOUS">CONTINUOUS</option>
              <option value="DASHED">DASHED</option>
              <option value="DOTTED">DOTTED</option>
            </select>
          </div>
          <div class="row">
            <button id="applyProps">Apply</button>
          </div>
        </div>

        <h3>System</h3>
        <div class="row">
          <label for="units">Units</label>
          <select id="units">
            <option value="unitless" selected>Unitless</option>
            <option value="mm">mm</option>
            <option value="cm">cm</option>
            <option value="m">m</option>
            <option value="inch">inch</option>
            <option value="ft">ft</option>
          </select>
        </div>
      </div>
    </aside>

    <div id="hud">
      <div class="row"><span class="key">Len</span><span id="hudLen" class="active">—</span></div>
      <div class="row"><span class="key">Ang</span><span id="hudAng">—</span></div>
      <div class="row" style="font-size:12px"><span>dx,dy</span><span id="hudDXDY">—</span></div>
      <div class="row" style="font-size:12px"><span>snap</span><span id="hudSnap">—</span></div>
      <div class="row" style="font-size:12px"><span>hint</span><span>Tab switch · Enter accept</span></div>
    </div>
    <pre id="err"></pre>
    <div id="ctx" class="ctxmenu hidden" role="menu" aria-hidden="true"></div>
  </div>

  <div id="modelTabs">
    <div class="mltab active">Model</div>
    <div class="mltab">Layout1</div>
    <div class="mltab">Layout2</div>
  </div>

  <div id="statusBar">
    <div>Mode: <span id="modeLbl" class="pill">Select</span> <span id="okpill2" class="pill" style="margin-left:.5rem"></span></div>
    <div id="cliWrap">
      <div id="cmdHistory"></div>
      <input id="cmdInput" type="text" placeholder="Command: L, PL, A, C, REC, TR, PO, T, MI, O, S, CHA, M, CO, RO, SC, E, Z, BMAKE, BINS, EXPLODE, M2P" />
    </div>
    <div class="st-right">
      <label class="st-toggle" title="Show Grid">
        <input type="checkbox" id="showGrid" checked /> Grid
      </label>
      <label class="st-toggle" title="Snap to Grid">
        <input type="checkbox" id="snapGrid" checked /> Snap Grid
      </label>
      <label class="st-toggle" title="Endpoint Snap">
        <input type="checkbox" id="snapEnds" checked /> End
      </label>
      <label class="st-toggle" title="Midpoint Snap">
        <input type="checkbox" id="snapMids" checked /> Mid
      </label>
      <label class="st-toggle" title="Intersection Snap">
        <input type="checkbox" id="snapInters" /> Int
      </label>
      <label class="st-toggle" title="Ortho (F8)">
        <input type="checkbox" id="orthoLock" /> Ortho
      </label>
      <label class="st-toggle" title="Grid Step">
        Step <input id="gridStep" type="number" min="5" max="500" step="5" value="50" style="width:4.5rem; background:#0b0f1f; color:#f2f6ff; border:1px solid #263050; border-radius:.25rem; padding:.1rem .3rem" />
      </label>
      <label class="st-toggle" title="AutoCAD-style crosshair">
        <input type="checkbox" id="bigCross" checked /> ACAD Cur
      </label>
      <label class="st-toggle" title="Pickbox size">
        Pick <input id="pickSize" type="number" min="4" max="40" step="1" value="12" style="width:3.5rem; background:#0b0f1f; color:#f2f6ff; border:1px solid #263050; border-radius:.25rem; padding:.1rem .3rem" />
      </label>
      <span class="pill">Snap <span id="snapLbl">—</span></span>
      <span class="pill">Cursor <span id="cursorLbl">0,0</span></span>
      <span class="pill">Zoom <span id="zoomLbl">100%</span></span>
      <span class="pill">Units <span id="unitsLbl">unitless</span></span>
    </div>
  </div>
</div>

<script>
/* ==========================================================
   Mini-CAD Engine (AutoCAD-style UI shell) — Single-file build
   ========================================================== */
(function(){
  const okPill  = document.getElementById('okpill');
  const okPill2 = document.getElementById('okpill2');
  const errBox  = document.getElementById('err');
  function showErr(msg){
    errBox.style.display='block';
    errBox.textContent = String(msg);
    okPill.textContent='Error ✗';
    okPill.style.background='#4a1212';
    okPill2.textContent='Error';
  }
  window.addEventListener('error', e=>{
    showErr((e.message||'error') + (e.filename? ("\n"+e.filename+":"+e.lineno):''));
  });

  try{
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d');
    if(!ctx) throw new Error('2D canvas not available.');
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const H2 = (a,b)=>Math.sqrt(a*a+b*b);

    /* ---------- Core State ---------- */
    const state = {
      scale: 1.0, ox: 0, oy: 0,
      mode: 'select',
      mouse: {x:0,y:0, wx:0, wy:0},
      grid: {step: 50},
      snaps: {grid:true, ends:true, mids:true, inters:false},
      ortho: false, showGrid: true,
      cursor: {big:true, pick:12},
      layers: [{name:'0', color:'#e0e6ff', visible:true}],
      currentLayer: '0',
      blocks: {},
      drawing: {entities: [], selection: {}},
      action: null,
      viewPrev: null,
      history: [], future: [],
      lastCmd: '',
      dyn: {active:false, field:'len', lenStr:'', angStr:'', lastBase:null},
      pickOverride:null,
      units:'unitless'
    };

    /* ---------- HUD ---------- */
    const hud = document.getElementById('hud');
    const hudLen = document.getElementById('hudLen');
    const hudAng = document.getElementById('hudAng');
    const hudDXDY = document.getElementById('hudDXDY');
    const hudSnap = document.getElementById('hudSnap');

    /* ---------- Utils ---------- */
    function setCanvasSize(){
      const rect = canvas.getBoundingClientRect();
      canvas.width = Math.max(100, Math.floor(rect.width * dpr));
      canvas.height = Math.max(100, Math.floor(rect.height * dpr));
      ctx.setTransform(dpr,0,0,dpr,0,0);
      if(state.ox===0 && state.oy===0){ state.ox=rect.width/2; state.oy=rect.height/2; state.scale=1.0; }
      draw();
    }
    const w2s=(x,y)=>({x:x*state.scale+state.ox, y:-y*state.scale+state.oy});
    const s2w=(sx,sy)=>({x:(sx-state.ox)/state.scale, y:-(sy-state.oy)/state.scale});
    const fmt=v=>(Math.round(v*100)/100).toFixed(2);
    const clamp=(v,a,b)=>Math.max(a, Math.min(b, v));
    const css=name=>getComputedStyle(document.documentElement).getPropertyValue(name).trim() || '#888';
    function currentLayerObj(){ return state.layers.find(L=>L.name===state.currentLayer) || state.layers[0]; }
    function currentLayerColor(name){ return (state.layers.find(L=>L.name===name)||{}).color || '#e0e6ff'; }

    /* ---------- History ---------- */
    function snapshot(){
      state.history.push(JSON.stringify({entities:state.drawing.entities, layers:state.layers, currentLayer:state.currentLayer, blocks:state.blocks}));
      if(state.history.length>200) state.history.shift();
      state.future.length=0;
    }
    function undo(){
      if(!state.history.length) return;
      state.future.push(JSON.stringify({entities:state.drawing.entities, layers:state.layers, currentLayer:state.currentLayer, blocks:state.blocks}));
      const d=JSON.parse(state.history.pop());
      state.drawing.entities=d.entities||[]; state.layers=d.layers||state.layers; state.currentLayer=d.currentLayer||'0'; state.blocks=d.blocks||{};
      rebuildLayerUI(); rebuildBlockUI(); clearSelection(); draw();
    }
    function redo(){
      if(!state.future.length) return;
      state.history.push(JSON.stringify({entities:state.drawing.entities, layers:state.layers, currentLayer:state.currentLayer, blocks:state.blocks}));
      const d=JSON.parse(state.future.pop());
      state.drawing.entities=d.entities||[]; state.layers=d.layers||state.layers; state.currentLayer=d.currentLayer||'0'; state.blocks=d.blocks||{};
      rebuildLayerUI(); rebuildBlockUI(); clearSelection(); draw();
    }

    /* ---------- Rendering ---------- */
    function draw(){
      ctx.setTransform(1,0,0,1,0,0);
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.setTransform(dpr,0,0,dpr,0,0);
      drawGrid(); drawEntities(); drawOverlays(); drawCrosshair();
      const snap=getSnap(state.mouse.wx,state.mouse.wy, state.mouse.x, state.mouse.y, state.pickOverride);
      document.getElementById('cursorLbl').textContent = fmt(state.mouse.wx)+','+fmt(state.mouse.wy);
      document.getElementById('zoomLbl').textContent = Math.round(state.scale*100)+'%';
      document.getElementById('snapLbl').textContent = snap? (state.pickOverride? (state.pickOverride+'*'):snap.kind) : '—';
      document.getElementById('unitsLbl').textContent = state.units;
      updateHUD(snap);
    }
    function drawGrid(){
      if(!state.showGrid) return;
      const rect = canvas.getBoundingClientRect();
      const stepW = state.grid.step, stepS = stepW * state.scale;
      const majorEvery = 5, majorStepS = stepS * majorEvery;
      const left=-state.ox, right=rect.width-state.ox, top=-state.oy, bottom=rect.height-state.oy;
      const startXMinor=Math.floor(left/stepS)*stepS, startYMinor=Math.floor(top/stepS)*stepS;
      const startXMajor=Math.floor(left/majorStepS)*majorStepS, startYMajor=Math.floor(top/majorStepS)*majorStepS;

      ctx.save(); ctx.translate(state.ox,state.oy);
      if(stepS < 8){
        const dotGap = Math.max(majorStepS, 24);
        const sx = Math.floor(left/dotGap)*dotGap;
        const sy = Math.floor(top/dotGap)*dotGap;
        ctx.fillStyle = css('--grid-major');
        for(let x=sx;x<=right;x+=dotGap){
          for(let y=sy;y<=bottom;y+=dotGap){
            ctx.fillRect(x-0.5,y-0.5,1.5,1.5);
          }
        }
      } else {
        ctx.beginPath();
        for(let x2=startXMinor;x2<=right;x2+=stepS){ ctx.moveTo(x2,top); ctx.lineTo(x2,bottom); }
        for(let y2=startYMinor;y2<=bottom;y2+=stepS){ ctx.moveTo(left,y2); ctx.lineTo(right,y2); }
        ctx.lineWidth = 1; ctx.strokeStyle = css('--grid-minor'); ctx.stroke();

        ctx.beginPath();
        for(let x3=startXMajor;x3<=right;x3+=majorStepS){ ctx.moveTo(x3,top); ctx.lineTo(x3,bottom); }
        for(let y3=startYMajor;y3<=bottom;y3+=majorStepS){ ctx.moveTo(left,y3); ctx.lineTo(right,y3); }
        ctx.lineWidth = 1.5; ctx.strokeStyle = css('--grid-major'); ctx.stroke();
      }
      ctx.beginPath(); ctx.moveTo(-state.ox,0); ctx.lineTo(rect.width-state.ox,0); ctx.moveTo(0,-state.oy); ctx.lineTo(0,rect.height-state.oy);
      ctx.lineWidth=1.2; ctx.strokeStyle=css('--axis'); ctx.stroke();
      ctx.restore();
    }
    function entVisible(e){
      for(let i=0;i<state.layers.length;i++){ const L=state.layers[i]; if(L.name===e.layer){ return L.visible!==false; } }
      return true;
    }
    function strokeFor(e){
      ctx.lineWidth=1.6;
      const col = e.color || currentLayerColor(e.layer) || '#e0e6ff';
      ctx.strokeStyle = col;
      if(e.ltype==='DASHED'){ ctx.setLineDash([8,6]); }
      else if(e.ltype==='DOTTED'){ ctx.setLineDash([2,6]); }
      else { ctx.setLineDash([]); }
    }
    function drawEntities(){
      ctx.lineCap='round'; ctx.lineJoin='round';
      for(let i=0;i<state.drawing.entities.length;i++){
        const e = state.drawing.entities[i];
        if(!entVisible(e)) continue;
        if(e.type==='blockref'){ drawBlockRef(e); continue; }
        if(e.type==='text'){ drawTextEnt(e); continue; }
        if(e.type==='point'){ drawPointEnt(e); continue; }
        strokeFor(e);
        ctx.beginPath();
        for(let j=0;j<e.pts.length;j++){
          const p = w2s(e.pts[j].x, e.pts[j].y);
          if(j===0) ctx.moveTo(p.x, p.y); else ctx.lineTo(p.x, p.y);
        }
        if(e.closed && e.pts.length>1){ const p0=w2s(e.pts[0].x,e.pts[0].y); ctx.lineTo(p0.x,p0.y); }
        ctx.stroke();
        if(state.drawing.selection[i]){
          for(let k=0;k<e.pts.length;k++){ drawGrip(e.pts[k]); }
          for(let m=0;m<e.pts.length-1;m++){ drawMidGrip({x:(e.pts[m].x+e.pts[m+1].x)/2, y:(e.pts[m].y+e.pts[m+1].y)/2}); }
        }
      }
      ctx.setLineDash([]);
    }
    function drawTextEnt(te){
      const s=w2s(te.pos.x, te.pos.y);
      ctx.save();
      ctx.fillStyle = te.color || currentLayerColor(te.layer) || '#e0e6ff';
      ctx.font = (Math.max(10, te.size*state.scale/2)|0)+'px Arial';
      ctx.textBaseline='alphabetic';
      ctx.fillText(te.text || 'TXT', s.x, s.y);
      ctx.restore();
    }
    function drawPointEnt(pe){
      const s=w2s(pe.pos.x, pe.pos.y);
      ctx.save();
      ctx.strokeStyle = pe.color || currentLayerColor(pe.layer) || '#e0e6ff';
      ctx.beginPath();
      ctx.moveTo(s.x-5, s.y); ctx.lineTo(s.x+5, s.y);
      ctx.moveTo(s.x, s.y-5); ctx.lineTo(s.x, s.y+5);
      ctx.stroke();
      ctx.restore();
    }
    function drawBlockRef(br){
      const blk=state.blocks[br.ref]; if(!blk) return;
      const col = br.color || currentLayerColor(br.layer) || '#e0e6ff';
      const ang= (br.rot||0)*Math.PI/180, sc=br.scale||1, cos=Math.cos(ang), sin=Math.sin(ang);
      function T(pt){
        const x=(pt.x - blk.base.x)*sc, y=(pt.y - blk.base.y)*sc;
        return {x: br.pos.x + x*cos - y*sin, y: br.pos.y + x*sin + y*cos};
      }
      ctx.strokeStyle = col; ctx.lineWidth=1.6; ctx.setLineDash([]);
      for(let i=0;i<blk.entities.length;i++){
        const e=blk.entities[i];
        if(e.type==='poly'){
          ctx.beginPath();
          for(let j=0;j<e.pts.length;j++){
            const p = w2s(T(e.pts[j]).x, T(e.pts[j]).y);
            if(j===0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y);
          }
          if(e.closed && e.pts.length>1){ const p0=T(e.pts[0]); const s0=w2s(p0.x,p0.y); ctx.lineTo(s0.x,s0.y); }
          ctx.stroke();
        } else if(e.type==='point'){
          const p=T(e.pos); const s=w2s(p.x,p.y); ctx.beginPath(); ctx.moveTo(s.x-3,s.y); ctx.lineTo(s.x+3,s.y); ctx.moveTo(s.x,s.y-3); ctx.lineTo(s.x,s.y+3); ctx.stroke();
        } else if(e.type==='text'){
          const p=T(e.pos); const s=w2s(p.x,p.y); ctx.save(); ctx.fillStyle=col; ctx.font=(Math.max(10, e.size*state.scale/2)|0)+'px Arial'; ctx.fillText(e.text||'TXT', s.x, s.y); ctx.restore();
        }
      }
    }
    function drawOverlays(){
      if(state.action && state.action.type==='box'){
        const x = Math.min(state.action.x0,state.action.x1);
        const y = Math.min(state.action.y0,state.action.y1);
        const w = Math.abs(state.action.x1-state.action.x0);
        const h = Math.abs(state.action.y1-state.action.y0);
        ctx.fillStyle=css('--sel'); ctx.strokeStyle='#7aa2ffaa'; ctx.lineWidth=1; ctx.fillRect(x,y,w,h); ctx.strokeRect(x,y,w,h);
      }
      if(state.action && state.action.type && state.action.pts && state.action.pts.length){
        const A=state.action, pts=A.pts;
        ctx.strokeStyle=css('--accent2'); ctx.setLineDash([6,4]); ctx.beginPath();
        if(A.type==='drawRect' && pts.length>=1){
          const a=pts[0]; const b=A.preview||a;
          const r=[{x:a.x,y:a.y},{x:b.x,y:a.y},{x:b.x,y:b.y},{x:a.x,y:b.y},{x:a.x,y:a.y}];
          for(let i=0;i<r.length;i++){ const s=w2s(r[i].x,r[i].y); if(i===0) ctx.moveTo(s.x,s.y); else ctx.lineTo(s.x,s.y); }
        } else if(A.type==='drawCircle' && pts.length>=1){
          const c=pts[0]; const b2=A.preview||c; const rad=H2(b2.x-c.x, b2.y-c.y); const N=64;
          for(let k=0;k<=N;k++){ const ang=k/N*2*Math.PI; const s2=w2s(c.x+rad*Math.cos(ang), c.y+rad*Math.sin(ang)); if(k===0) ctx.moveTo(s2.x,s2.y); else ctx.lineTo(s2.x,s2.y); }
        } else if(A.type==='arc3p' && pts.length>=1){
          const st=pts[0], mid=A.preview||pts[1]||st, en=pts[1]||st;
          const N2=48; const s0=w2s(st.x,st.y); ctx.moveTo(s0.x,s0.y);
          for(let t=0;t<=N2;t++){ const u=t/N2; const q=quadThrough3(st,mid,en,u); const s3=w2s(q.x,q.y); if(t===0) ctx.moveTo(s3.x,s3.y); else ctx.lineTo(s3.x,s3.y); }
        } else {
          for(let j=0;j<pts.length;j++){ const s3=w2s(pts[j].x,pts[j].y); if(j===0) ctx.moveTo(s3.x,s3.y); else ctx.lineTo(s3.x,s3.y); }
          if(A.preview){ const s4=w2s(A.preview.x,A.preview.y); ctx.lineTo(s4.x,s4.y); }
        }
        ctx.stroke(); ctx.setLineDash([]);
      }
    }
    function drawGrip(p){ const s=w2s(p.x,p.y); ctx.fillStyle=css('--accent'); const r=4.5; ctx.fillRect(s.x-r,s.y-r,r*2,r*2); }
    function drawMidGrip(p){ const s=w2s(p.x,p.y); ctx.fillStyle='#9de6ff'; const r=3.5; ctx.fillRect(s.x-r,s.y-r,r*2,r*2); }

    /* ---------- Crosshair ---------- */
    function drawCrosshair(){
      if(!state.cursor.big) return;
      const x=state.mouse.x, y=state.mouse.y;
      ctx.save();
      ctx.setLineDash([]); ctx.lineWidth=1; ctx.strokeStyle='rgba(173, 197, 255, 0.7)';
      ctx.beginPath();
      ctx.moveTo(0,y+0.5); ctx.lineTo(canvas.width/dpr, y+0.5);
      ctx.moveTo(x+0.5,0); ctx.lineTo(x+0.5, canvas.height/dpr);
      ctx.stroke();
      const r=state.cursor.pick;
      ctx.strokeStyle='rgba(173, 197, 255, 0.9)';
      ctx.strokeRect(Math.round(x-r)+0.5, Math.round(y-r)+0.5, r*2, r*2);
      ctx.restore();
    }

    /* ---------- Snapping ---------- */
    function getSnap(wx,wy,sx,sy, override){
      const ap=12; let best=null, bestD=1e9;
      function trySnap(x,y,kind){
        const s=w2s(x,y); const dx=s.x-sx, dy=s.y-sy; const d=H2(dx,dy);
        if(d<=ap && d<bestD){ bestD=d; best={x:x,y:y,kind:kind}; }
      }
      let i,j,e;
      if((state.snaps.ends && !override) || override==='end'){
        for(i=0;i<state.drawing.entities.length;i++){
          e=state.drawing.entities[i]; if(!entVisible(e)) continue;
          if(e.type==='blockref'){ snapBlockEnds(e, trySnap); }
          else if(e.type==='poly'){ for(j=0;j<e.pts.length;j++){ trySnap(e.pts[j].x, e.pts[j].y, 'end'); } }
          else if(e.type==='point'){ trySnap(e.pos.x,e.pos.y,'end'); }
        }
      }
      if((state.snaps.mids && !override) || override==='mid'){
        for(i=0;i<state.drawing.entities.length;i++){
          e=state.drawing.entities[i]; if(!entVisible(e)) continue;
          if(e.type==='blockref'){ snapBlockMids(e, trySnap); }
          else if(e.type==='poly'){ for(j=0;j<e.pts.length-1;j++){ trySnap((e.pts[j].x+e.pts[j+1].x)/2, (e.pts[j].y+e.pts[j+1].y)/2, 'mid'); } }
        }
      }
      if(((state.snaps.inters && !override) || override==='int')){
        const segs = collectNearSegments(sx,sy,14);
        for(let a=0;a<segs.length;a++){
          for(let b=0;b<segs.length;b++){
            if(b<=a) continue;
            const P = segIntersect(segs[a].a, segs[a].b, segs[b].a, segs[b].b);
            if(P) trySnap(P.x, P.y, 'int');
          }
        }
      }
      if(state.snaps.grid && !override){
        const step=state.grid.step; trySnap(Math.round(wx/step)*step, Math.round(wy/step)*step, 'grid');
      }
      return best;
    }
    function collectNearSegments(sx,sy,pix){
      const res=[]; let i,j,e,a,b,sa,sb,d;
      for(i=0;i<state.drawing.entities.length;i++){
        e=state.drawing.entities[i]; if(!entVisible(e)) continue;
        if(e.type==='blockref'){ collectBlockSegments(e,res,sx,sy,pix); continue; }
        if(e.type!=='poly') continue;
        for(j=0;j<e.pts.length-1;j++){
          a=e.pts[j]; b=e.pts[j+1];
          sa=w2s(a.x,a.y); sb=w2s(b.x,b.y);
          d = distToSeg({x:sx,y:sy}, sa, sb);
          if(d<=pix) res.push({a:a, b:b});
        }
      }
      return res;
    }
    function collectBlockSegments(br,res,sx,sy,pix){
      const blk=state.blocks[br.ref]; if(!blk) return;
      const ang=(br.rot||0)*Math.PI/180, sc=br.scale||1, cos=Math.cos(ang), sin=Math.sin(ang);
      function T(pt){ const x=(pt.x - blk.base.x)*sc, y=(pt.y - blk.base.y)*sc; return {x: br.pos.x + x*cos - y*sin, y: br.pos.y + x*sin + y*cos}; }
      for(let i=0;i<blk.entities.length;i++){
        const e=blk.entities[i]; if(e.type!=='poly') continue;
        for(let j=0;j<e.pts.length-1;j++){
          const a=T(e.pts[j]), b=T(e.pts[j+1]), sa=w2s(a.x,a.y), sb=w2s(b.x,b.y);
          const d=distToSeg({x:sx,y:sy},sa,sb);
          if(d<=pix) res.push({a:a,b:b});
        }
      }
    }
    function distToSeg(p,a,b){
      const vx=b.x-a.x, vy=b.y-a.y;
      const wx=p.x-a.x, wy=p.y-a.y;
      const c1=vx*wx+vy*wy;
      if(c1<=0) return Math.sqrt(wx*wx+wy*wy);
      const c2=vx*vx+vy*vy;
      if(c2<=c1) return Math.sqrt((p.x-b.x)*(p.x-b.x)+(p.y-b.y)*(p.y-b.y));
      const t=c1/c2;
      const qx=a.x+t*vx, qy=a.y+t*vy;
      return Math.sqrt((p.x-qx)*(p.x-qx)+(p.y-qy)*(p.y-qy));
    }
    function segIntersect(a1,a2,b1,b2){
      const x1=a1.x, y1=a1.y, x2=a2.x, y2=a2.y;
      const x3=b1.x, y3=b1.y, x4=b2.x, y4=b2.y;
      const den=(x1-x2)*(y3-y4)-(y1-y2)*(x3-x4);
      if(Math.abs(den)<1e-9) return null;
      const px=((x1*y2 - y1*x2)*(x3 - x4) - (x1 - x2)*(x3*y4 - y3*x4))/den;
      const py=((x1*y2 - y1*x2)*(y3 - y4) - (y1 - y2)*(x3*y4 - y3*x4))/den;
      const within=(x,a,b)=>{ const min=Math.min(a,b)-1e-6, max=Math.max(a,b)+1e-6; return x>=min && x<=max; };
      if(within(px,x1,x2) && within(py,y1,y2) && within(px,x3,x4) && within(py,y3,y4)) return {x:px,y:py};
      return null;
    }
    function snapBlockEnds(br, cb){
      const blk=state.blocks[br.ref]; if(!blk) return;
      const ang=(br.rot||0)*Math.PI/180, sc=br.scale||1, cos=Math.cos(ang), sin=Math.sin(ang);
      function T(pt){ const x=(pt.x - blk.base.x)*sc, y=(pt.y - blk.base.y)*sc; return {x: br.pos.x + x*cos - y*sin, y: br.pos.y + x*sin + y*cos}; }
      for(let i=0;i<blk.entities.length;i++){
        const e=blk.entities[i]; if(e.type!=='poly') continue;
        for(let j=0;j<e.pts.length;j++){ const p=T(e.pts[j]); cb(p.x,p.y,'end'); }
      }
    }
    function snapBlockMids(br, cb){
      const blk=state.blocks[br.ref]; if(!blk) return;
      const ang=(br.rot||0)*Math.PI/180, sc=br.scale||1, cos=Math.cos(ang), sin=Math.sin(ang);
      function T(pt){ const x=(pt.x - blk.base.x)*sc, y=(pt.y - blk.base.y)*sc; return {x: br.pos.x + x*cos - y*sin, y: br.pos.y + x*sin + y*cos}; }
      for(let i=0;i<blk.entities.length;i++){
        const e=blk.entities[i]; if(e.type!=='poly') continue;
        for(let j=0;j<e.pts.length-1;j++){ const a=T(e.pts[j]), b=T(e.pts[j+1]); cb((a.x+b.x)/2,(a.y+b.y)/2,'mid'); }
      }
    }
    function applyOrtho(last,cur){
      const dx=cur.x-last.x, dy=cur.y-last.y;
      if(Math.abs(dx)>Math.abs(dy)) return {x:cur.x,y:last.y};
      return {x:last.x,y:cur.y};
    }
    function clearSelection(){ state.drawing.selection={}; updateSelInfo(); }
    function setSelected(i, on){ if(on) state.drawing.selection[i]=true; else delete state.drawing.selection[i]; updateSelInfo(); }
    function selectionIndices(){ const out=[]; for(const k in state.drawing.selection){ if(Object.prototype.hasOwnProperty.call(state.drawing.selection,k)) out.push(parseInt(k,10)); } return out.sort((a,b)=>a-b); }
    function updateSelInfo(){ const count=selectionIndices().length; document.getElementById('selInfo').textContent = count; }

    /* ---------- Dynamic Input HUD ---------- */
    function enableDyn(base){ state.dyn.active=true; state.dyn.field='len'; state.dyn.lenStr=''; state.dyn.angStr=''; state.dyn.lastBase=base; hud.style.display='block'; hudLen.className='active'; hudAng.className=''; }
    function disableDyn(){ state.dyn.active=false; hud.style.display='none'; }
    function parseDyn(){ const len=parseFloat(state.dyn.lenStr); const ang=parseFloat(state.dyn.angStr); return {len:isFinite(len)?len:null, ang:isFinite(ang)?ang:null}; }
    function applyDynFrom(base, raw){
      const d=parseDyn();
      let px=raw.x, py=raw.y;
      if(d.ang!=null && d.len!=null){ const rad=d.ang*Math.PI/180; px = base.x + d.len*Math.cos(rad); py = base.y + d.len*Math.sin(rad); }
      else if(d.len!=null){ const vx=raw.x-base.x, vy=raw.y-base.y; const L=H2(vx,vy)||1; px = base.x + d.len*(vx/L); py = base.y + d.len*(vy/L); }
      else if(d.ang!=null){ const rad2=d.ang*Math.PI/180; const L2=H2(raw.x-base.x, raw.y-base.y); px = base.x + L2*Math.cos(rad2); py = base.y + L2*Math.sin(rad2); }
      return {x:px,y:py};
    }
    function updateHUD(snap){
      const rect = canvas.getBoundingClientRect();
      const x=state.mouse.x+14, y=state.mouse.y+14;
      hud.style.left = Math.min(rect.width-160, Math.max(0,x))+'px';
      hud.style.top = Math.min(rect.height-90, Math.max(0,y))+'px';
      const base = state.dyn.lastBase;
      let cur = {x:state.mouse.wx, y:state.mouse.wy};
      if(snap){ cur={x:snap.x,y:snap.y}; }
      if(base){
        const dx=cur.x-base.x, dy=cur.y-base.y;
        const len=H2(dx,dy), ang=Math.atan2(dy,dx)*180/Math.PI;
        hudDXDY.textContent = fmt(dx)+','+fmt(dy);
        hudLen.textContent = state.dyn.lenStr===''? fmt(len) : state.dyn.lenStr;
        hudAng.textContent = state.dyn.angStr===''? fmt(ang) : state.dyn.angStr;
      } else { hudDXDY.textContent='—'; hudLen.textContent='—'; hudAng.textContent='—'; }
      hudSnap.textContent = snap? snap.kind : '—';
      hud.style.display = (state.dyn.active && (state.mode==='line' || state.mode==='poly' || state.mode==='rect' || state.mode==='circle' || state.mode==='arc3p'))? 'block':'none';
    }

    /* ---------- Context Menu ---------- */
    const ctxMenu = document.getElementById('ctx');
    let ctxOpen = false;
    function hideCtx(){
      if(!ctxOpen) return;
      ctxOpen=false;
      ctxMenu.classList.add('hidden');
      ctxMenu.innerHTML='';
      ctxMenu.setAttribute('aria-hidden','true');
    }
    function showCtx(pageX,pageY, items){
      buildCtxDom(items, ctxMenu);
      positionCtx(pageX,pageY);
      ctxOpen=true;
      ctxMenu.classList.remove('hidden');
      ctxMenu.setAttribute('aria-hidden','false');
    }
    function positionCtx(px,py){
      const rect = canvas.getBoundingClientRect();
      const right = Math.min(rect.right-8, px);
      const bottom= Math.min(rect.bottom-8, py);
      ctxMenu.style.left = right + 'px';
      ctxMenu.style.top  = bottom + 'px';
    }
    function buildCtxDom(items, root){
      root.innerHTML='';
      root.className='ctxmenu';
      (items||[]).forEach(it=>{
        if(it === 'sep'){ const sep=document.createElement('div'); sep.className='sep'; root.appendChild(sep); return; }
        const row=document.createElement('div');
        row.className='item'+(it.disabled?' disabled':'')+(it.submenu?' group':'');
        row.setAttribute('role','menuitem');
        const left=document.createElement('div');
        const check=document.createElement('span'); check.className='check'; check.textContent = it.checked?'•':'';
        const label=document.createElement('span'); label.className='label'; label.textContent=it.label||'';
        left.appendChild(check); left.appendChild(label);
        const right=document.createElement('div');
        right.className='accel';
        if(it.accel) right.textContent=it.accel;
        if(it.submenu){ const caret=document.createElement('span'); caret.className='submenu'; right.appendChild(caret); }
        row.appendChild(left); row.appendChild(right);
        if(!it.disabled && it.action){ row.addEventListener('click', ev=>{ ev.stopPropagation(); hideCtx(); try{ it.action(); }catch(_){} }); }
        if(it.submenu){
          const panel=document.createElement('div'); panel.className='ctxmenu submenu-panel hidden';
          buildCtxDom(it.submenu, panel);
          row.appendChild(panel);
          row.addEventListener('mouseenter', ()=> panel.classList.remove('hidden'));
          row.addEventListener('mouseleave', ()=> panel.classList.add('hidden'));
        }
        root.appendChild(row);
      });
    }
    window.addEventListener('click', hideCtx);
    window.addEventListener('blur', hideCtx);
    window.addEventListener('keydown', e=>{ if(e.key==='Escape') hideCtx(); });

    /* ---------- Mouse & interactions ---------- */
    let isPanning=false, panX0=0, panY0=0, ox0=0, oy0=0;
    let dragGrip=null;

    canvas.addEventListener('contextmenu', function(e){
      e.preventDefault();
      const rect=canvas.getBoundingClientRect();
      const sx=e.clientX-rect.left, sy=e.clientY-rect.top;
      const w=s2w(sx,sy);
      state.mouse.x=sx; state.mouse.y=sy; state.mouse.wx=w.x; state.mouse.wy=w.y;
      const items = buildAutoCADStyleMenu(sx,sy);
      showCtx(e.clientX, e.clientY, items);
      return false;
    });

    function isDrawing(){
      return state.action && (
        state.action.type==='drawLine' || state.action.type==='drawPoly' ||
        state.action.type==='drawRect' || state.action.type==='drawCircle' ||
        state.action.type==='arc3p' || state.action.type==='zoomwin'
      );
    }
    function selectionCount(){ return selectionIndices().length; }
    function hitIndexAtScreen(sx,sy){ return hitEntityAt(sx,sy); }
    function finishCurrent(){
      if(!state.action) return;
      if(state.action.type==='drawPoly' && state.action.pts.length>=2){
        snapshot(); state.drawing.entities.push({type:'poly', pts:state.action.pts.slice(0), closed:false, layer:state.currentLayer});
        state.action=null; disableDyn(); draw(); return;
      }
      if(state.action.type==='drawLine' && state.action.pts && state.action.pts.length===2){
        snapshot(); state.drawing.entities.push({type:'poly', pts:[state.action.pts[0], state.action.pts[1]], closed:false, layer:state.currentLayer});
        state.action=null; disableDyn(); draw(); return;
      }
      if(state.action.type==='drawRect' || state.action.type==='drawCircle' || state.action.type==='arc3p'){ cancelAction(); return; }
    }
    function undoLastVertex(){
      if(!state.action || !state.action.pts) return;
      if(state.action.pts.length>0){ state.action.pts.pop(); state.dyn.lastBase = state.action.pts[state.action.pts.length-1] || null; draw(); }
    }
    function buildAutoCADStyleMenu(sx,sy){
      const idx = hitIndexAtScreen(sx,sy);
      const hasSel = selectionCount()>0;
      const drawing = isDrawing();

      const snaps = state.snaps;
      const drawGroup = [
        {label:'Line',   accel:'L', action:()=>startCmd('line')},
        {label:'Polyline', accel:'PL', action:()=>startCmd('pline')},
        {label:'Rectangle', accel:'REC', action:()=>startCmd('rect')},
        {label:'Circle', accel:'C', action:()=>startCmd('circle')},
        {label:'Arc (3-Point)', accel:'A', action:()=>startCmd('arc3p')},
        {label:'Text', accel:'T', action:()=>startCmd('text')}
      ];
      const modifyGroup = [
        {label:'Move', accel:'M', action:()=>startCmd('move'), disabled:!hasSel},
        {label:'Copy', accel:'CO', action:()=>startCmd('copy'), disabled:!hasSel},
        {label:'Rotate', accel:'RO', action:()=>startCmd('rotate'), disabled:!hasSel},
        {label:'Scale', accel:'SC', action:()=>startCmd('scale'), disabled:!hasSel},
        {label:'Erase', accel:'E', action:()=>startCmd('erase'), disabled:!hasSel},
      ];
      const blockGroup = [
        {label:'Make Block', accel:'B', action:()=>startCmd('bmake'), disabled:!hasSel},
        {label:'Insert Block', accel:'I', action:()=>startCmd('bins')},
        {label:'Explode', accel:'X', action:()=>startCmd('explode'), disabled:!hasSel}
      ];
      const snapGroup = [
        {label:'Snap Grid', checked:snaps.grid, action:()=>{snaps.grid=!snaps.grid; draw();}},
        {label:'Snap End',  checked:snaps.ends, action:()=>{snaps.ends=!snaps.ends; draw();}},
        {label:'Snap Mid',  checked:snaps.mids, action:()=>{snaps.mids=!snaps.mids; draw();}},
        {label:'Snap Int',  checked:snaps.inters, action:()=>{snaps.inters=!snaps.inters; draw();}},
        'sep',
        {label:'Force End (E)', accel:'E', action:()=>{state.pickOverride='end';}},
        {label:'Force Mid (M)', accel:'M', action:()=>{state.pickOverride='mid';}},
        {label:'Force Int (I)', accel:'I', action:()=>{state.pickOverride='int';}}
      ];
      const viewGroup = [
        {label:'Pan', accel:'Middle/RMB drag', action:()=>{ setMode('pan'); activateBtn('tb-pan'); }},
        {label:'Zoom Window', accel:'Z→W', action:()=>{ state.action={type:'zoomwin',stage:0}; activateBtn('tb-zoom-win'); }},
        {label:'Zoom Previous', accel:'Z→P', action:()=>{ zoomPrevious(); }},
        {label:'Zoom Extents', accel:'Z→E', action:()=>{ zoomExtents(); }},
        'sep',
        {label:'Grid Display', checked:state.showGrid, action:()=>{ state.showGrid=!state.showGrid; document.getElementById('showGrid').checked=state.showGrid; draw(); }},
        {label:'Ortho (F8)', checked:state.ortho, action:()=>{ state.ortho=!state.ortho; document.getElementById('orthoLock').checked=state.ortho; }}
      ];
      const unitsGroup = [
        {label:'Unitless', checked:state.units==='unitless', action:()=>{ state.units='unitless'; document.getElementById('units').value='unitless'; draw(); }},
        {label:'mm',       checked:state.units==='mm',       action:()=>{ state.units='mm';       document.getElementById('units').value='mm'; draw(); }},
        {label:'cm',       checked:state.units==='cm',       action:()=>{ state.units='cm';       document.getElementById('units').value='cm'; draw(); }},
        {label:'m',        checked:state.units==='m',        action:()=>{ state.units='m';        document.getElementById('units').value='m'; draw(); }},
        {label:'inch',     checked:state.units==='inch',     action:()=>{ state.units='inch';     document.getElementById('units').value='inch'; draw(); }},
        {label:'ft',       checked:state.units==='ft',       action:()=>{ state.units='ft';       document.getElementById('units').value='ft'; draw(); }}
      ];

      const objectGroup = [];
      if(idx!==-1){
        objectGroup.push(
          {label:'Select/Deselect', action:()=>{ setSelected(idx, !state.drawing.selection[idx]); draw(); }},
          {label:'Properties…', action:()=>{ toggleDrawer(true); }}
        );
      }

      if(drawing){
        const canClose = state.action.type==='drawPoly' && state.action.pts && state.action.pts.length>=2;
        return [
          {label:'Finish', accel:'Enter', action:finishCurrent},
          {label:'Undo last point', accel:'Backspace', action:undoLastVertex, disabled:!(state.action.pts && state.action.pts.length)},
          canClose ? {label:'Close polyline', accel:'C (dbl-click)', action:()=>{ 
            const pts = state.action.pts.slice(0); if(pts.length>=2){ pts.push(pts[0]); snapshot(); state.drawing.entities.push({type:'poly', pts:pts, closed:true, layer:state.currentLayer}); state.action=null; disableDyn(); draw(); }
          }} : null,
          {label:'Set Temporary Origin', accel:'Shift+O', action:()=>{ const snap=getSnap(state.mouse.wx,state.mouse.wy,state.mouse.x,state.mouse.y,state.pickOverride); state.dyn.lastBase = snap? {x:snap.x,y:snap.y}:{x:state.mouse.wx,y:state.mouse.wy}; draw(); }},
          'sep',
          {label:'Cancel', accel:'Esc', action:()=>{ cancelAction(); }},
          'sep',
          {label:'Snaps', submenu:snapGroup},
          {label:'View',  submenu:viewGroup},
          {label:'Units', submenu:unitsGroup}
        ].filter(Boolean);
      }

      const top = [
        {label:'Repeat ' + (state.lastCmd? state.lastCmd.toUpperCase() : 'Command'), accel:'Space', action:()=>{ if(state.lastCmd) startCmd(state.lastCmd); }},
        'sep'
      ];
      const selOps = hasSel ? [
        {label:'Properties…', action:()=>{ toggleDrawer(true); }},
        {label:'Erase', accel:'E', action:()=>startCmd('erase')},
        'sep'
      ] : [];

      return top
        .concat(objectGroup.length? objectGroup.concat(['sep']) : [])
        .concat([
          {label:'Draw',   submenu:drawGroup},
          {label:'Modify', submenu:modifyGroup, disabled:!hasSel},
          {label:'Blocks', submenu:blockGroup},
          {label:'View',   submenu:viewGroup},
          {label:'Snaps',  submenu:snapGroup},
          {label:'Units',  submenu:unitsGroup},
        ])
        .concat(selOps);
    }

    /* ---------- Mouse press ---------- */
    canvas.addEventListener('mousedown', function(e){
      const rect=canvas.getBoundingClientRect();
      const x=e.clientX-rect.left, y=e.clientY-rect.top;
      const w=s2w(x,y);
      state.mouse.x=x; state.mouse.y=y; state.mouse.wx=w.x; state.mouse.wy=w.y;

      if(state.action && state.action.type==='zoomwin'){
        if(!state.action.first){ state.action.first={x:x,y:y}; state.action.x0=x; state.action.y0=y; state.action.x1=x; state.action.y1=y; state.action.boxing=true; return; }
        else { doZoomWindowPx(state.action.first, {x:x,y:y}); state.action=null; draw(); return; }
      }

      if(e.button===1 || e.button===2 || state.mode==='pan'){ isPanning=true; panX0=x; panY0=y; ox0=state.ox; oy0=state.oy; return; }

      const g = hitGripAt(x,y);
      if(g){ snapshot(); dragGrip=g; return; }

      if(state.mode==='select'){
        const idx=hitEntityAt(x,y);
        if(idx!==-1){ if(!e.shiftKey) clearSelection(); setSelected(idx, !state.drawing.selection[idx]); draw(); }
        else { state.action={type:'box', x0:x,y0:y,x1:x,y1:y}; }
        return;
      }

      if(state.mode==='point'){
        snapshot(); state.drawing.entities.push({type:'point', pos:{x:w.x,y:w.y}, layer:state.currentLayer}); draw(); return;
      }
      if(state.mode==='text'){
        const txt=prompt('Enter text:', 'TEXT'); let sz=parseFloat(prompt('Text height:', '20')||'20'); if(!isFinite(sz)) sz=20;
        snapshot(); state.drawing.entities.push({type:'text', text:txt||'TEXT', size:sz, pos:{x:w.x,y:w.y}, layer:state.currentLayer}); draw(); return;
      }
      if(state.mode==='arc3p'){
        if(!state.action){ state.action={type:'arc3p', pts:[{x:w.x,y:w.y}]}; enableDyn(state.action.pts[0]); draw(); return; }
        state.action.pts.push({x:w.x,y:w.y});
        if(state.action.pts.length===3){
          const st=state.action.pts[0], mid=state.action.pts[1], en=state.action.pts[2];
          const pts=[]; for(let t=0;t<=48;t++){ const u=t/48; const q=quadThrough3(st,mid,en,u); pts.push(q); }
          snapshot(); state.drawing.entities.push({type:'poly', pts:pts, closed:false, layer:state.currentLayer}); state.action=null; disableDyn(); draw();
        } else { draw(); }
        return;
      }
      if(state.mode==='line' || state.mode==='poly'){
        if(!state.action){ state.action={type: state.mode==='line'? 'drawLine':'drawPoly', pts: []}; }
        if(state.action.pts.length===0){ enableDyn({x:w.x,y:w.y}); }
        const s=getSnap(w.x,w.y,x,y,state.pickOverride);
        const raw = s? {x:s.x,y:s.y} : {x:w.x,y:w.y};
        let pt = (state.dyn.active && state.dyn.lastBase)? applyDynFrom(state.dyn.lastBase, raw) : raw;
        if(state.ortho && state.action.pts.length){ pt=applyOrtho(state.action.pts[state.action.pts.length-1], pt); }
        state.action.pts.push(pt); state.dyn.lastBase=pt; state.pickOverride=null; draw(); return;
      }
      if(state.mode==='rect'){
        if(!state.action){ state.action={type:'drawRect', pts:[{x:w.x,y:w.y}]}; enableDyn(state.action.pts[0]); draw(); return; }
        const rawR={x:w.x,y:w.y}; const ptR=(state.dyn.active && state.dyn.lastBase)? applyDynFrom(state.dyn.lastBase, rawR) : rawR;
        state.action.pts[1]=ptR;
        const a=state.action.pts[0], b=state.action.pts[1];
        const r=[{x:a.x,y:a.y},{x:b.x,y:a.y},{x:b.x,y:b.y},{x:a.x,y:b.y}];
        snapshot(); state.drawing.entities.push({type:'poly', pts:r, closed:true, layer:state.currentLayer}); state.action=null; disableDyn(); draw(); return;
      }
      if(state.mode==='circle'){
        if(!state.action){ state.action={type:'drawCircle', pts:[{x:w.x,y:w.y}]}; enableDyn(state.action.pts[0]); draw(); return; }
        const cen=state.action.pts[0];
        const rawC={x:w.x,y:w.y}; const ptC=(state.dyn.active && state.dyn.lastBase)? applyDynFrom(state.dyn.lastBase, rawC) : rawC;
        const rad=H2(ptC.x-cen.x, ptC.y-cen.y);
        snapshot(); addCircleAsPoly(cen,rad, state.currentLayer, null); state.action=null; disableDyn(); draw(); return;
      }
    });

    window.addEventListener('dblclick', function(){
      if(state.action && state.action.type==='drawPoly' && state.action.pts.length>=2){
        snapshot(); state.drawing.entities.push({type:'poly', pts:state.action.pts.slice(0), closed:false, layer:state.currentLayer}); state.action=null; disableDyn(); draw();
      }
    });

    window.addEventListener('mousemove', function(e){
      const rect=canvas.getBoundingClientRect();
      const x=e.clientX-rect.left, y=e.clientY-rect.top;
      const w=s2w(x,y);
      state.mouse.x=x; state.mouse.y=y; state.mouse.wx=w.x; state.mouse.wy=w.y;

      if(isPanning){ state.ox = ox0 + (x - panX0); state.oy = oy0 + (y - panY0); draw(); return; }
      if(state.action && state.action.boxing){ state.action.x1=x; state.action.y1=y; draw(); return; }

      if(dragGrip){
        const eidx=dragGrip.ei, vi=dragGrip.vi;
        const s=getSnap(w.x,w.y,x,y,state.pickOverride);
        const rawG = s? {x:s.x,y:s.y} : {x:w.x,y:w.y};
        const ent=state.drawing.entities[eidx]; if(ent){ if(vi==='base'){ ent.pos=rawG; } else { ent.pts[vi]=rawG; } draw(); }
        return;
      }

      if(state.action && state.action.type==='box'){
        state.action.x1=x; state.action.y1=y;
        const xMin=Math.min(state.action.x0,state.action.x1), xMax=Math.max(state.action.x0,state.action.x1);
        const yMin=Math.min(state.action.y0,state.action.y1), yMax=Math.max(state.action.y0,state.action.y1);
        clearSelection();
        for(let i=0;i<state.drawing.entities.length;i++){
          const e2=state.drawing.entities[i]; if(!entVisible(e2)) continue;
          let inside=true;
          if(e2.type==='poly'){
            for(let j=0;j<e2.pts.length;j++){ const s2=w2s(e2.pts[j].x,e2.pts[j].y); if(s2.x<xMin||s2.x>xMax||s2.y<yMin||s2.y>yMax){ inside=false; break; } }
          } else if(e2.type==='blockref'){
            const sb=w2s(e2.pos.x,e2.pos.y); inside = !(sb.x<xMin||sb.x>xMax||sb.y<yMin||sb.y>yMax);
          } else if(e2.type==='text' || e2.type==='point'){
            const ss=w2s((e2.pos||{x:0}).x,(e2.pos||{y:0}).y); inside = !(ss.x<xMin||ss.x>xMax||ss.y<yMin||ss.y>yMax);
          }
          if(inside) setSelected(i,true);
        }
        draw(); return;
      }

      if(state.action && state.action.type && state.action.type.indexOf('draw')===0){
        const base = state.action.pts.length? state.action.pts[state.action.pts.length-1] : null;
        const s=getSnap(w.x,w.y,x,y,state.pickOverride);
        const raw = s? {x:s.x,y:s.y} : {x:w.x,y:w.y};
        let pt = (state.dyn.active && state.dyn.lastBase)? applyDynFrom(state.dyn.lastBase, raw) : raw;
        if(state.ortho && base){ pt=applyOrtho(base, pt); }
        state.action.preview=pt; draw(); return;
      }
      if(state.action && state.action.type==='arc3p' && state.action.pts.length>=1){
        const sA=getSnap(w.x,w.y,x,y,state.pickOverride);
        state.action.preview = sA? {x:sA.x,y:sA.y}: {x:w.x,y:w.y};
        draw(); return;
      }
      draw();
    });

    window.addEventListener('mouseup', function(){
      isPanning=false;
      if(dragGrip){ dragGrip=null; draw(); return; }
      if(state.action && state.action.type==='drawLine'){
        if(state.action.pts.length===2){
          snapshot(); state.drawing.entities.push({type:'poly', pts:[state.action.pts[0], state.action.pts[1]], closed:false, layer:state.currentLayer}); state.action=null; disableDyn(); draw();
        }
        return;
      }
      if(state.action && state.action.type==='box'){ state.action=null; draw(); return; }
    });

    canvas.addEventListener('wheel', function(e){
      e.preventDefault();
      const rect=canvas.getBoundingClientRect(); const x=e.clientX-rect.left, y=e.clientY-rect.top; const before=s2w(x,y);
      const delta = e.deltaY || e.wheelDelta || 0;
      const factor = Math.exp(-(delta)*0.15/100);
      state.scale=clamp(state.scale*factor, 0.1, 20);
      const after=w2s(before.x,before.y);
      state.ox += (x-after.x); state.oy += (y-after.y);
      draw();
    }, {passive:false});

    /* ---------- Hit tests ---------- */
    function hitEntityAt(sx,sy){
      const tol=10; let best=-1, bestD=1e9;
      for(let i=0;i<state.drawing.entities.length;i++){
        const e=state.drawing.entities[i]; if(!entVisible(e)) continue;
        if(e.type==='blockref'){
          const s=w2s(e.pos.x,e.pos.y);
          const d=H2(sx-s.x, sy-s.y);
          if(d<tol && d<bestD){ bestD=d; best=i; }
          continue;
        }
        if(e.type==='text' || e.type==='point'){
          const sp=w2s((e.pos||{x:0}).x,(e.pos||{y:0}).y);
          const d0=H2(sx-sp.x, sy-sp.y); if(d0<tol && d0<bestD){ bestD=d0; best=i; }
          continue;
        }
        for(let j=0;j<e.pts.length-1;j++){
          const a=w2s(e.pts[j].x,e.pts[j].y), b=w2s(e.pts[j+1].x,e.pts[j+1].y);
          const d2=distToSeg({x:sx,y:sy},a,b);
          if(d2<tol && d2<bestD){ bestD=d2; best=i; }
        }
      }
      return best;
    }
    function hitGripAt(sx,sy){
      const tol=8;
      for(let i=0;i<state.drawing.entities.length;i++){
        if(!state.drawing.selection[i]) continue;
        const e=state.drawing.entities[i];
        if(e.type==='blockref'){
          const sb=w2s(e.pos.x,e.pos.y); if(Math.abs(sx-sb.x)<=tol && Math.abs(sy-sb.y)<=tol) return {ei:i, vi:'base'}; continue;
        }
        if(e.type==='text' || e.type==='point'){
          const sp=w2s((e.pos||{x:0}).x,(e.pos||{y:0}).y); if(Math.abs(sx-sp.x)<=tol && Math.abs(sy-sp.y)<=tol) return {ei:i, vi:'base'};
        }
        if(e.type==='poly'){
          for(let j=0;j<e.pts.length;j++){
            const s2=w2s(e.pts[j].x,e.pts[j].y);
            if(Math.abs(sx-s2.x)<=tol && Math.abs(sy-s2.y)<=tol) return {ei:i, vi:j};
          }
        }
      }
      return null;
    }

    /* ---------- Commands & keyboard ---------- */
    const cmdInput = document.getElementById('cmdInput');
    const cmdHistory = document.getElementById('cmdHistory');
    function pushHistory(line){ cmdHistory.textContent = line; }
    function setMode(m){ state.mode=m; document.getElementById('modeLbl').textContent=m.charAt(0).toUpperCase()+m.slice(1); draw(); }
    function activateBtn(id){ document.querySelectorAll('.tool-btn').forEach(b=>b.classList.remove('active')); const el=document.getElementById(id); if(el) el.classList.add('active'); }
    function startCmd(name){
      state.lastCmd=name; pushHistory(name.toUpperCase());
      if(name==='point'){ setMode('point'); activateBtn('tb-point'); cmdInput.value=''; return; }
      if(name==='text'){ setMode('text'); activateBtn('tb-text'); cmdInput.value=''; return; }
      if(name==='arc3p' || name==='arc'){ setMode('arc3p'); activateBtn('tb-arc'); cmdInput.value=''; return; }
      if(name==='line') { setMode('line'); activateBtn('tb-line'); cmdInput.value=''; return; }
      if(name==='pline'){ setMode('poly'); activateBtn('tb-poly'); cmdInput.value=''; return; }
      if(name==='rect'){ setMode('rect'); activateBtn('tb-rect'); cmdInput.value=''; return; }
      if(name==='circle'){ setMode('circle'); activateBtn('tb-circle'); cmdInput.value=''; return; }
      if(name==='trace'){ setMode('poly'); activateBtn('tb-trace'); cmdInput.value=''; return; }

      if(name==='move'){ ensureSelection(); state.action={type:'modify', kind:'move', stage:0}; activateBtn('tb-move'); return; }
      if(name==='copy'){ ensureSelection(); state.action={type:'modify', kind:'copy', stage:0}; activateBtn('tb-copy'); return; }
      if(name==='rotate'){ ensureSelection(); state.action={type:'modify', kind:'rotate', stage:0}; activateBtn('tb-rotate'); return; }
      if(name==='scale'){ ensureSelection(); state.action={type:'modify', kind:'scale', stage:0}; activateBtn('tb-scale'); return; }
      if(name==='mirror'){ alert('Mirror stub.'); return; }
      if(name==='offset'){ alert('Offset stub.'); return; }
      if(name==='stretch'){ alert('Stretch stub.'); return; }
      if(name==='chamfer'){ alert('Chamfer stub.'); return; }

      if(name==='erase'){ eraseSelection(); cmdInput.value=''; return; }
      if(name==='zoom'){ state.action={type:'zoomwin', stage:0}; activateBtn('tb-zoom-win'); return; }
      if(name==='bmake'){ doMakeBlock(); return; }
      if(name==='bins'){ doInsertBlock(); return; }
      if(name==='explode'){ explodeSelected(); return; }
      if(name==='m2p'){ startM2P(); return; }
      if(name==='id'){ alert('ID: '+fmt(state.mouse.wx)+','+fmt(state.mouse.wy)); return; }
      if(name==='dist'){ alert('DIST: pick 2 points (use snaps).'); return; }
      if(name==='area'){ alert('AREA: select closed poly in future version.'); return; }
    }
    function ensureSelection(){ if(selectionIndices().length===0){ setMode('select'); } }
    function handleCmdEnter(txt){
      const t=(txt||'').trim().toLowerCase();
      if(state.action && state.action.type==='modify'){
        if(state.action.kind==='rotate'){ const ang=parseFloat(t); if(isFinite(ang)){ applyRotate(ang, state.action.base||{x:0,y:0}, false); state.action=null; draw(); pushHistory('Rotate '+ang+'°'); return; } }
        if(state.action.kind==='scale'){ const fac=parseFloat(t); if(isFinite(fac)){ applyScale(fac, state.action.base||{x:0,y:0}, false); state.action=null; draw(); pushHistory('Scale ×'+fac); return; } }
      }
      if(!t){ if(state.lastCmd) startCmd(state.lastCmd); return; }
      if(t==='po' || t==='point'){ startCmd('point'); return; }
      if(t==='t' || t==='text'){ startCmd('text'); return; }
      if(t==='a' || t==='arc'){ startCmd('arc3p'); return; }
      if(t==='l' || t==='line'){ startCmd('line'); return; }
      if(t==='pl' || t==='pline'){ startCmd('pline'); return; }
      if(t==='tr' || t==='trace'){ startCmd('trace'); return; }
      if(t==='rec' || t==='rect' || t==='rectangle'){ startCmd('rect'); return; }
      if(t==='c' || t==='circle'){ startCmd('circle'); return; }
      if(t==='m' || t==='move'){ startCmd('move'); return; }
      if(t==='co' || t==='copy'){ startCmd('copy'); return; }
      if(t==='ro' || t==='rotate'){ startCmd('rotate'); return; }
      if(t==='sc' || t==='scale'){ startCmd('scale'); return; }
      if(t==='mi' || t==='mirror'){ startCmd('mirror'); return; }
      if(t==='o' || t==='offset'){ startCmd('offset'); return; }
      if(t==='s' || t==='stretch'){ startCmd('stretch'); return; }
      if(t==='cha' || t==='chamfer'){ startCmd('chamfer'); return; }
      if(t==='e' || t==='erase' || t==='del'){ startCmd('erase'); return; }
      if(t==='z' || t==='zoom'){ startCmd('zoom'); return; }
      if(t==='bmake' || t==='b'){ startCmd('bmake'); return; }
      if(t==='bins' || t==='i'){ startCmd('bins'); return; }
      if(t==='explode' || t==='x'){ startCmd('explode'); return; }
      if(t==='m2p'){ startCmd('m2p'); return; }
      if(t==='id'){ startCmd('id'); return; }
      if(t==='dist'){ startCmd('dist'); return; }
      if(t==='area'){ startCmd('area'); return; }
    }
    cmdInput.addEventListener('keydown', function(e){
      if(e.key==='Enter'){ handleCmdEnter(cmdInput.value); cmdInput.value=''; }
      if(e.key==='Escape'){ cancelAction(); }
      if(e.key===' ' && !cmdInput.value){ if(state.lastCmd) startCmd(state.lastCmd); e.preventDefault(); }
    });
    document.getElementById('searchAll').addEventListener('keydown', e=>{
      if(e.key==='Enter'){ const v=e.currentTarget.value.trim(); if(v){ handleCmdEnter(v); e.currentTarget.value=''; } else { cmdInput.focus(); } }
    });

    window.addEventListener('keydown', function(e){
      const tag=document.activeElement && document.activeElement.tagName ? document.activeElement.tagName.toLowerCase() : '';
      if(tag!=='input' && tag!=='textarea'){
        if(e.key==='E' || e.key==='e'){ state.pickOverride='end'; return; }
        if(e.key==='M' || e.key==='m'){ state.pickOverride='mid'; return; }
        if(e.key==='I' || e.key==='i'){ state.pickOverride='int'; return; }
        if((state.mode==='line'||state.mode==='poly'||state.mode==='rect'||state.mode==='circle'||state.mode==='arc3p') && state.dyn.active){
          if(e.key==='Tab'){ e.preventDefault(); if(state.dyn.field==='len'){ state.dyn.field='ang'; hudLen.className=''; hudAng.className='active'; } else { state.dyn.field='len'; hudLen.className='active'; hudAng.className=''; } draw(); return; }
          if(e.key==='Backspace'){ if(state.dyn.field==='len'){ state.dyn.lenStr=state.dyn.lenStr.slice(0,-1); } else { state.dyn.angStr=state.dyn.angStr.slice(0,-1); } draw(); return; }
          if((e.key>='0' && e.key<='9') || e.key==='.' || e.key==='-'){ if(state.dyn.field==='len'){ state.dyn.lenStr+=e.key; } else { state.dyn.angStr+=e.key; } draw(); return; }
        }
        if(e.key && e.key.length===1 && !e.ctrlKey && !e.metaKey && !e.altKey){ cmdInput.value=e.key; cmdInput.focus(); try{ cmdInput.setSelectionRange(1,1); }catch(_e){} }
      }
      if((e.ctrlKey||e.metaKey) && (e.key==='z' || e.key==='Z')){ e.preventDefault(); undo(); }
      if((e.ctrlKey||e.metaKey) && (e.key==='y' || (e.shiftKey && (e.key==='Z' || e.key==='z')))){ e.preventDefault(); redo(); }
      if((e.ctrlKey||e.metaKey) && (e.key==='s' || e.key==='S')){ e.preventDefault(); saveJSON(); }
      if((e.ctrlKey||e.metaKey) && (e.key==='o' || e.key==='O')){ e.preventDefault(); document.getElementById('fileInput').click(); }
      if(e.key==='F8'){ state.ortho=!state.ortho; document.getElementById('orthoLock').checked=state.ortho; }
      if(e.key==='v' || e.key==='V'){ setMode('select'); activateBtn('tb-select'); }
    });

    function cancelAction(){ state.action=null; disableDyn(); state.pickOverride=null; draw(); }

    /* ---------- Modify (move/copy/rotate/scale) ---------- */
    function applyTranslate(dx,dy, asCopy){
      snapshot();
      const idxs=selectionIndices();
      if(asCopy){
        const newIdx=[];
        for(let i=0;i<idxs.length;i++){
          const e=state.drawing.entities[idxs[i]];
          const copy = cloneEntity(e);
          translateEntity(copy,dx,dy);
          state.drawing.entities.push(copy);
          newIdx.push(state.drawing.entities.length-1);
        }
        state.drawing.selection={}; for(let i=0;i<newIdx.length;i++){ state.drawing.selection[newIdx[i]]=true; }
      } else {
        for(let i=0;i<idxs.length;i++){ translateEntity(state.drawing.entities[idxs[i]],dx,dy); }
      }
      draw();
    }
    function translateEntity(e,dx,dy){
      if(e.type==='poly'){ for(let k=0;k<e.pts.length;k++){ e.pts[k].x+=dx; e.pts[k].y+=dy; } }
      if(e.type==='blockref'){ e.pos.x+=dx; e.pos.y+=dy; }
      if(e.type==='text'||e.type==='point'){ e.pos.x+=dx; e.pos.y+=dy; }
    }
    function cloneEntity(e){
      if(e.type==='poly'){ const pts=[]; for(let j=0;j<e.pts.length;j++){ pts.push({x:e.pts[j].x,y:e.pts[j].y}); } return {type:'poly', pts:pts, closed:e.closed, layer:e.layer, color:e.color, ltype:e.ltype}; }
      if(e.type==='blockref'){ return {type:'blockref', ref:e.ref, pos:{x:e.pos.x,y:e.pos.y}, rot:(e.rot||0), scale:(e.scale||1), layer:e.layer, color:e.color}; }
      if(e.type==='text'){ return {type:'text', text:e.text, size:e.size, pos:{x:e.pos.x,y:e.pos.y}, layer:e.layer, color:e.color}; }
      if(e.type==='point'){ return {type:'point', pos:{x:e.pos.x,y:e.pos.y}, layer:e.layer, color:e.color}; }
      return null;
    }
    function applyRotate(angleDeg, base, asCopy){
      snapshot();
      const idxs=selectionIndices();
      if(asCopy){
        const newIdx=[];
        for(let i=0;i<idxs.length;i++){ const c=cloneEntity(state.drawing.entities[idxs[i]]); rotateEntity(c,angleDeg,base); state.drawing.entities.push(c); newIdx.push(state.drawing.entities.length-1); }
        state.drawing.selection={}; for(let i=0;i<newIdx.length;i++){ state.drawing.selection[newIdx[i]]=true; }
      } else { for(let i=0;i<idxs.length;i++){ rotateEntity(state.drawing.entities[idxs[i]], angleDeg, base); } }
      draw();
    }
    function rotateEntity(e,angDeg,base){
      const ang=angDeg*Math.PI/180, cos=Math.cos(ang), sin=Math.sin(ang);
      function R(pt){ const qx=pt.x-base.x, qy=pt.y-base.y; return {x: base.x + qx*cos - qy*sin, y: base.y + qx*sin + qy*cos}; }
      if(e.type==='poly'){ for(let j=0;j<e.pts.length;j++){ const p=R(e.pts[j]); e.pts[j].x=p.x; e.pts[j].y=p.y; } }
      else if(e.type==='blockref'){ const qx2=e.pos.x-base.x, qy2=e.pos.y-base.y; e.pos.x = base.x + qx2*cos - qy2*sin; e.pos.y = base.y + qx2*sin + qy2*cos; e.rot = (e.rot||0)+angDeg; }
      else if(e.type==='text' || e.type==='point'){ const p2=R(e.pos); e.pos.x=p2.x; e.pos.y=p2.y; }
    }
    function applyScale(fac, base, asCopy){
      snapshot();
      const idxs=selectionIndices();
      if(asCopy){
        const newIdx=[];
        for(let i=0;i<idxs.length;i++){ const c=cloneEntity(state.drawing.entities[idxs[i]]); scaleEntity(c,fac,base); state.drawing.entities.push(c); newIdx.push(state.drawing.entities.length-1); }
        state.drawing.selection={}; for(let i=0;i<newIdx.length;i++){ state.drawing.selection[newIdx[i]]=true; }
      } else { for(let i=0;i<idxs.length;i++){ scaleEntity(state.drawing.entities[idxs[i]], fac, base); } }
      draw();
    }
    function scaleEntity(e,fac,base){
      if(e.type==='poly'){ for(let j=0;j<e.pts.length;j++){ const qx=e.pts[j].x-base.x, qy=e.pts[j].y-base.y; e.pts[j].x = base.x + qx*fac; e.pts[j].y = base.y + qy*fac; } }
      else if(e.type==='blockref'){ const qx2=e.pos.x-base.x, qy2=e.pos.y-base.y; e.pos.x = base.x + qx2*fac; e.pos.y = base.y + qy2*fac; e.scale = (e.scale||1)*fac; }
      else if(e.type==='text' || e.type==='point'){ const qx3=e.pos.x-base.x, qy3=e.pos.y-base.y; e.pos.x = base.x + qx3*fac; e.pos.y = base.y + qy3*fac; if(e.type==='text') e.size*=fac; }
    }
    function firstSelectedPoint(){
      const idxs=selectionIndices(); if(!idxs.length) return null;
      const e=state.drawing.entities[idxs[0]];
      if(e.type==='poly'){ return e && e.pts && e.pts[0] ? {x:e.pts[0].x, y:e.pts[0].y} : null; }
      if(e.type==='blockref'||e.type==='text'||e.type==='point'){ return {x:e.pos.x,y:e.pos.y}; }
      return null;
    }
    function eraseSelection(){
      const idxs=selectionIndices(); if(!idxs.length) return;
      snapshot();
      const keep=[];
      for(let i=0;i<state.drawing.entities.length;i++){ if(state.drawing.selection[i]) continue; keep.push(state.drawing.entities[i]); }
      state.drawing.entities=keep; clearSelection(); draw();
    }

    /* ---------- Toolbar wiring ---------- */
    const q = sel=>document.querySelector(sel);
    q('#tb-select').onclick=()=>{ setMode('select'); activateBtn('tb-select'); state.action=null; disableDyn(); };
    q('#tb-point').onclick =()=> startCmd('point');
    q('#tb-text').onclick  =()=> startCmd('text');
    q('#tb-arc').onclick   =()=> startCmd('arc3p');
    q('#tb-line').onclick  =()=> startCmd('line');
    q('#tb-poly').onclick  =()=> startCmd('pline');
    q('#tb-trace').onclick =()=> startCmd('trace');
    q('#tb-rect').onclick  =()=> startCmd('rect');
    q('#tb-circle').onclick=()=> startCmd('circle');
    q('#tb-move').onclick  =()=> startCmd('move');
    q('#tb-copy').onclick  =()=> startCmd('copy');
    q('#tb-rotate').onclick=()=> startCmd('rotate');
    q('#tb-scale').onclick =()=> startCmd('scale');
    q('#tb-erase').onclick =()=> startCmd('erase');
    q('#tb-mirror').onclick=()=> startCmd('mirror');
    q('#tb-offset').onclick=()=> startCmd('offset');
    q('#tb-stretch').onclick=()=> startCmd('stretch');
    q('#tb-chamfer').onclick=()=> startCmd('chamfer');
    q('#tb-pan').onclick   =()=> { setMode('pan'); activateBtn('tb-pan'); };
    q('#tb-zoom-win').onclick=()=> { state.action={type:'zoomwin',stage:0}; activateBtn('tb-zoom-win'); };
    q('#tb-zoom-prev').onclick=()=> zoomPrevious();
    q('#tb-zoom-ext').onclick =()=> zoomExtents();
    q('#tb-make-block').onclick=()=> startCmd('bmake');
    q('#tb-insert-block').onclick=()=> startCmd('bins');
    q('#tb-explode').onclick=()=> startCmd('explode');
    q('#m2pBtn').onclick=()=> startCmd('m2p');

    document.querySelectorAll('.ribbon-tab').forEach(t=>{
      t.addEventListener('click', ()=>{
        document.querySelectorAll('.ribbon-tab').forEach(x=>x.classList.remove('active'));
        t.classList.add('active');
      });
    });

    const sideDrawer = document.getElementById('sideDrawer');
    function toggleDrawer(forceOpen){
      if(forceOpen===true){ sideDrawer.style.display='block'; return; }
      sideDrawer.style.display = (sideDrawer.style.display==='block' ? 'none':'block');
    }
    document.getElementById('toggleDrawer').onclick=()=>toggleDrawer();

    document.getElementById('openBtn').onclick =()=> document.getElementById('fileInput').click();
    document.getElementById('saveBtn').onclick =()=> saveJSON();
    document.getElementById('saveDxfBtn').onclick=()=> saveDXF();
    document.getElementById('undoBtn').onclick=()=>undo();
    document.getElementById('redoBtn').onclick=()=>redo();
    document.getElementById('fileInput').addEventListener('change', onOpenFile);

    document.getElementById('showGrid').addEventListener('change', e=>{ state.showGrid=e.target.checked; draw(); });
    document.getElementById('snapGrid').addEventListener('change', e=>{ state.snaps.grid=e.target.checked; draw(); });
    document.getElementById('snapEnds').addEventListener('change', e=>{ state.snaps.ends=e.target.checked; draw(); });
    document.getElementById('snapMids').addEventListener('change', e=>{ state.snaps.mids=e.target.checked; draw(); });
    document.getElementById('snapInters').addEventListener('change', e=>{ state.snaps.inters=e.target.checked; draw(); });
    document.getElementById('orthoLock').addEventListener('change', e=>{ state.ortho=e.target.checked; });
    document.getElementById('gridStep').addEventListener('change', e=>{ const v=parseFloat(e.target.value); if(isFinite(v)&&v>0) state.grid.step=v; draw(); });
    document.getElementById('bigCross').addEventListener('change', e=>{ state.cursor.big=e.target.checked; draw(); });
    document.getElementById('pickSize').addEventListener('change', e=>{ const v=parseFloat(e.target.value); if(isFinite(v)&&v>0) state.cursor.pick=v; draw(); });
    document.getElementById('units').addEventListener('change', e=>{ state.units=e.target.value; draw(); });

    document.getElementById('navZoomIn').onclick = ()=>{ state.scale=clamp(state.scale*1.2,0.1,20); draw(); };
    document.getElementById('navZoomOut').onclick= ()=>{ state.scale=clamp(state.scale/1.2,0.1,20); draw(); };
    document.getElementById('navFit').onclick    = ()=> zoomExtents();
        document.getElementById('navPan').onclick    = ()=> { setMode('pan'); activateBtn('tb-pan'); };

    /* ===== Layers UI ===== */
    function rebuildLayerUI(){
      const sel = document.getElementById('layerSelect');
      const propSel=document.getElementById('propLayer');
      sel.innerHTML=''; propSel.innerHTML='';
      for(let i=0;i<state.layers.length;i++){
        const L = state.layers[i];
        const opt=document.createElement('option'); opt.value=L.name; opt.textContent=L.name + (L.visible===false?' (hidden)':''); sel.appendChild(opt);
        const opt2=document.createElement('option'); opt2.value=L.name; opt2.textContent=L.name; propSel.appendChild(opt2);
      }
      sel.value=state.currentLayer; propSel.value=state.currentLayer;
    }
    function currentLayerObj(){ return state.layers.find(L=>L.name===state.currentLayer) || state.layers[0]; }
    function ensureLayer(name, color){
      let L = state.layers.find(x=>x.name===name);
      if(!L){ L = {name:name||'0', color:color||'#e0e6ff', visible:true}; state.layers.push(L); rebuildLayerUI(); }
      return L;
    }
    function ensureLayersFromEntities(){
      const seen={};
      state.drawing.entities.forEach(e=>{ seen[e.layer||'0']=true; });
      Object.keys(seen).forEach(k=>ensureLayer(k));
    }
    document.getElementById('layerSelect').addEventListener('change', e=>{ state.currentLayer=e.target.value; });
    document.getElementById('addLayerBtn').onclick=function(){
      const name=document.getElementById('newLayerName').value || ('Layer'+(state.layers.length));
      const color=document.getElementById('newLayerColor').value || '#e0e6ff';
      ensureLayer(name, color); state.currentLayer=name; rebuildLayerUI();
    };
    document.getElementById('toggleLayerBtn').onclick=function(){
      const cur=currentLayerObj(); if(!cur) return; cur.visible = !cur.visible; rebuildLayerUI(); draw();
    };
    document.getElementById('delLayerBtn').onclick=function(){
      if(state.currentLayer==='0') return;
      snapshot();
      state.drawing.entities.forEach(e=>{ if(e.layer===state.currentLayer) e.layer='0'; });
      state.layers = state.layers.filter(L=>L.name!==state.currentLayer);
      state.currentLayer='0'; rebuildLayerUI(); draw();
    };
    document.getElementById('applyProps').onclick=function(){
      const newLayer=document.getElementById('propLayer').value;
      const newColor=document.getElementById('propColor').value;
      const newLtype=document.getElementById('propLtype').value;
      ensureLayer(newLayer);
      const idxs=selectionIndices(); if(!idxs.length) return;
      snapshot();
      idxs.forEach(i=>{
        const e=state.drawing.entities[i];
        e.layer=newLayer; e.color=newColor; e.ltype=newLtype;
      });
      draw();
    };

    /* ===== View helpers ===== */
    function zoomPrevious(){
      if(!state.viewPrev) return;
      const cur={ox:state.ox, oy:state.oy, scale:state.scale};
      state.ox=state.viewPrev.ox; state.oy=state.viewPrev.oy; state.scale=state.viewPrev.scale;
      state.viewPrev=cur; draw();
    }
    function rememberView(){ state.viewPrev={ox:state.ox, oy:state.oy, scale:state.scale}; }
    function zoomExtents(){
      const pad=40; // pixels of padding
      const rect=canvas.getBoundingClientRect();
      if(state.drawing.entities.length===0){ state.scale=1; state.ox=rect.width/2; state.oy=rect.height/2; draw(); return; }
      let minX=+1e9,minY=+1e9,maxX=-1e9,maxY=-1e9;
      function grow(x,y){ if(x<minX)minX=x; if(y<minY)minY=y; if(x>maxX)maxX=x; if(y>maxY)maxY=y; }
      state.drawing.entities.forEach(e=>{
        if(e.type==='poly'){ e.pts.forEach(p=>grow(p.x,p.y)); }
        else if(e.type==='text' || e.type==='point'){ grow(e.pos.x,e.pos.y); }
        else if(e.type==='blockref'){ grow(e.pos.x,e.pos.y); }
      });
      const w=maxX-minX||1, h=maxY-minY||1;
      const sx=(rect.width-2*pad)/w, sy=(rect.height-2*pad)/h;
      rememberView();
      state.scale=Math.max(0.1, Math.min(20, Math.min(sx,sy)));
      const cX=(minX+maxX)/2, cY=(minY+maxY)/2;
      const s=w2s(cX,cY);
      state.ox += (rect.width/2 - s.x);
      state.oy += (rect.height/2 - s.y);
      draw();
    }
    function doZoomWindowPx(a,b){
      const rect=canvas.getBoundingClientRect();
      const x0=Math.min(a.x,b.x), x1=Math.max(a.x,b.x);
      const y0=Math.min(a.y,b.y), y1=Math.max(a.y,b.y);
      const w=Math.max(10, x1-x0), h=Math.max(10, y1-y0);
      const wx = (w)/state.scale, wy=(h)/state.scale;
      const A=s2w(x0,y1), B=s2w(x1,y0);
      const worldW=B.x-A.x, worldH=B.y-A.y;
      const pad=20;
      rememberView();
      const sx=(rect.width-2*pad)/worldW, sy=(rect.height-2*pad)/worldH;
      state.scale=Math.max(0.1, Math.min(20, Math.min(sx,sy)));
      const cX=(A.x+B.x)/2, cY=(A.y+B.y)/2;
      const s=w2s(cX,cY);
      state.ox += (rect.width/2 - s.x);
      state.oy += (rect.height/2 - s.y);
    }

    /* ===== Geometry helpers ===== */
    function addCircleAsPoly(cen, rad, layer){
      const N=64; const pts=[];
      for(let k=0;k<N;k++){
        const a=k/N*2*Math.PI;
        pts.push({x:cen.x+rad*Math.cos(a), y:cen.y+rad*Math.sin(a)});
      }
      state.drawing.entities.push({type:'poly', pts:pts, closed:true, layer:layer||state.currentLayer});
    }
    function quadThrough3(st,mid,en,u){
      // simple quadratic Bezier recon from 3 points: st, mid (point on arc-ish), en
      // Assume param t where t in [0,1], and "mid" corresponds to t=0.5 for preview
      const t=u, one=1-t;
      // Reconstruct control point assuming mid at t=0.5: mid = (st + 2*Q + en)/4 => Q = 2*mid - (st+en)/2
      const Qx = 2*mid.x - 0.5*(st.x+en.x);
      const Qy = 2*mid.y - 0.5*(st.y+en.y);
      return {
        x: one*one*st.x + 2*one*t*Qx + t*t*en.x,
        y: one*one*st.y + 2*one*t*Qy + t*t*en.y
      };
    }

    /* ===== Move/Copy/Rotate/Scale base-pick ===== */
    canvas.addEventListener('mousedown', (e)=>{
      if(state.action && state.action.type==='modify'){
        const rect=canvas.getBoundingClientRect();
        const x=e.clientX-rect.left, y=e.clientY-rect.top;
        const base=s2w(x,y);
        if(state.action.stage===0){
          state.action.base=base; state.action.stage=1; pushHistory(state.action.kind.toUpperCase()+': base set');
        } else if(state.action.stage===1){
          if(state.action.kind==='move'){ const dx=base.x-state.action.base.x, dy=base.y-state.action.base.y; applyTranslate(dx,dy,false); state.action=null; draw(); }
          if(state.action.kind==='copy'){ const dx=base.x-state.action.base.x, dy=base.y-state.action.base.y; applyTranslate(dx,dy,true);  state.action=null; draw(); }
          if(state.action.kind==='rotate'){ pushHistory('Rotate: enter angle'); cmdInput.focus(); }
          if(state.action.kind==='scale'){  pushHistory('Scale: enter factor'); cmdInput.focus(); }
        }
      }
    }, {capture:true});

    /* ===== M2P (mid between 2 points) ===== */
    function startM2P(){
      pushHistory('M2P: pick first point');
      let step=0, A=null;
      function onClick(ev){
        const r=canvas.getBoundingClientRect();
        const p=s2w(ev.clientX-r.left, ev.clientY-r.top);
        if(step===0){ A=p; step=1; pushHistory('M2P: pick second point'); }
        else{
          const M={x:(A.x+p.x)/2, y:(A.y+p.y)/2};
          state.dyn.lastBase=M;
          pushHistory('M2P: base set to '+fmt(M.x)+','+fmt(M.y));
          canvas.removeEventListener('click', onClick, true);
        }
      }
      canvas.addEventListener('click', onClick, true);
    }

    /* ===== Blocks ===== */
    function rebuildBlockUI(){
      const list=document.getElementById('blockList'); list.innerHTML='';
      for(const k in state.blocks){ if(Object.prototype.hasOwnProperty.call(state.blocks,k)){ const o=document.createElement('option'); o.value=k; o.textContent=k; list.appendChild(o);} }
    }
    function doMakeBlock(){
      const idxs=selectionIndices(); if(!idxs.length){ alert('Select entities first.'); return; }
      const name=(document.getElementById('blockName').value||'Block') + '';
      const base=state.dyn.lastBase || firstSelectedPoint() || {x:0,y:0};
      const ents=[]; let i,j, e, pts;

      /* (your partial loop) */
      for(i=0;i<idxs.length;i++){
        e=state.drawing.entities[idxs[i]];
        if(e.type==='poly'){
          pts=[];
          for(j=0;j<e.pts.length;j++){ pts.push({x:e.pts[j].x,y:e.pts[j].y}); }
          ents.push({type:'poly', pts:pts, closed:e.closed, layer:e.layer, color:e.color});
        }
      }
      if(!ents.length){ alert('Only polyline-like entities supported for blocks in this version.'); return; }
      state.blocks[name]={name:name, base:{x:base.x,y:base.y}, entities:ents};
      rebuildBlockUI();
      alert('Block "'+name+'" created. Use Insert Block to place it.');
    }
    function doInsertBlock(){
      const name=(document.getElementById('blockName').value || document.getElementById('blockList').value || '').trim();
      if(!name || !state.blocks[name]){ alert('No such block "'+name+'".'); return; }
      pushHistory('BINS: pick insertion point');
      function onClick(ev){
        const r=canvas.getBoundingClientRect(); const p=s2w(ev.clientX-r.left, ev.clientY-r.top);
        snapshot();
        state.drawing.entities.push({type:'blockref', ref:name, pos:{x:p.x,y:p.y}, rot:0, scale:1, layer:state.currentLayer});
        canvas.removeEventListener('click', onClick, true);
        draw();
      }
      canvas.addEventListener('click', onClick, true);
    }
    function explodeSelected(){
      const idxs=selectionIndices().reverse(); if(!idxs.length){ alert('Select a block reference to explode.'); return; }
      snapshot();
      idxs.forEach(i=>{
        const e=state.drawing.entities[i];
        if(e.type!=='blockref') return;
        const blk=state.blocks[e.ref]; if(!blk) return;
        const ang=(e.rot||0)*Math.PI/180, sc=(e.scale||1), cos=Math.cos(ang), sin=Math.sin(ang);
        function T(pt){ const x=(pt.x - blk.base.x)*sc, y=(pt.y - blk.base.y)*sc; return {x: e.pos.x + x*cos - y*sin, y: e.pos.y + x*sin + y*cos}; }
        blk.entities.forEach(be=>{
          if(be.type==='poly'){
            const pts=be.pts.map(p=>T(p));
            state.drawing.entities.push({type:'poly', pts:pts, closed:be.closed, layer:e.layer, color:e.color||be.color});
          }
        });
      });
      // remove originals
      state.drawing.entities = state.drawing.entities.filter((_,i)=>!state.drawing.selection[i]);
      clearSelection(); draw();
    }

    /* ===== File I/O ===== */
    function saveJSON(){
      const data = {
        meta:{app:'mini-cad-2d', v:1},
        view:{ox:state.ox, oy:state.oy, scale:state.scale},
        layers:state.layers,
        currentLayer:state.currentLayer,
        blocks:state.blocks,
        entities:state.drawing.entities
      };
      const blob = new Blob([JSON.stringify(data,null,2)], {type:'application/json'});
      const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='drawing.json'; a.click();
      URL.revokeObjectURL(a.href);
    }
    function onOpenFile(ev){
      const f=ev.target.files && ev.target.files[0]; if(!f) return;
      const reader=new FileReader();
      reader.onload=function(){
        try{
          const txt=String(reader.result||'');
          if(f.name.toLowerCase().endsWith('.json') || txt.trim().startsWith('{')){
            const d=JSON.parse(txt);
            state.layers=d.layers||[{name:'0',color:'#e0e6ff',visible:true}];
            state.currentLayer=d.currentLayer||'0';
            state.blocks=d.blocks||{};
            state.drawing.entities=d.entities||[];
            if(d.view){ state.ox=d.view.ox||state.ox; state.oy=d.view.oy||state.oy; state.scale=d.view.scale||state.scale; }
            rebuildLayerUI(); rebuildBlockUI(); clearSelection(); draw();
          } else {
            alert('Only JSON is supported in this build.');
          }
        }catch(ex){ showErr(ex.message||ex); }
      };
      reader.readAsText(f);
      ev.target.value='';
    }
    function saveDXF(){
      // Minimal DXF writer: exports polylines only
      const lines=[];
      function push(k,v){ lines.push(String(k)); lines.push(String(v)); }
      push(0,'SECTION'); push(2,'ENTITIES');
      state.drawing.entities.forEach(e=>{
        if(e.type==='poly'){
          push(0,'LWPOLYLINE');
          push(90, e.pts.length + (e.closed?1:0));
          e.pts.forEach(p=>{ push(10, p.x); push(20, p.y); });
          if(e.closed && e.pts.length){ push(10, e.pts[0].x); push(20, e.pts[0].y); }
        }
      });
      push(0,'ENDSEC'); push(0,'EOF');
      const blob=new Blob([lines.join('\n')], {type:'application/dxf'});
      const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='drawing.dxf'; a.click();
      URL.revokeObjectURL(a.href);
    }

    /* ===== Boot ===== */
    window.addEventListener('resize', setCanvasSize);
    setCanvasSize();
    ensureLayer('0','#e0e6ff'); rebuildLayerUI(); rebuildBlockUI();
    okPill.textContent='OK ✓'; okPill2.textContent='Ready';
   } catch(ex){
    showErr(ex.message||ex);
  }
})();

</script>
</body>
</html>
